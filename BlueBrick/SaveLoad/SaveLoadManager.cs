// BlueBrick, a LEGO(c) layout editor.
// Copyright (C) 2008 Alban NANTY
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 3 of the License.
// see http://www.fsf.org/licensing/licenses/gpl.html
// and http://www.gnu.org/licenses/
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using BlueBrick.MapData;
using System.Drawing.Drawing2D;
using System.Drawing;
using System.Windows.Forms;
using BlueBrick.SaveLoad;
using System.Collections;

namespace BlueBrick
{
	public static class SaveLoadManager
    {
        #region unique Id
        /// <summary>
        /// This class encapsulate the representation of Unique Id for item that need to be saved.
        /// Before I used object.GetHashCode(), but that don't generate unique id.
        /// Now I use this class that encapsulate the id, so that I can control the way the id are
		/// generated through the various constructors.
        /// The default constructor will use a static counter that is incremented each time a new
		/// instance of UniqueId is created. The constructor that take a string as a parameter is used during
		/// loading, we set the id as what we read, but we also adjust the static counter, 
		/// so that newly created id after a loading can still stay unique.
        /// </summary>
        public class UniqueId
        {
			/// <summary>
			/// This struct is used internally to try to repair the files containing duplicated ids that have been
			/// generated by the GetHashCode() function. The struct is used to store the problematic ids in a second
			/// dictionary.
			/// </summary>
			private struct UniqueIdObjectPair
			{
				public UniqueId mUniqueId;
				public object mObject;
			}

			// this dictionnary containing all the objects associated with their id, is used to recreate the attachement of rulers to bricks when loading, or the connections between bricks
            private static Dictionary<ulong, object> sHashtableForRebuildingLinkAfterLoading = new Dictionary<ulong, object>();

			// this second dictionnary is mostly never used, it is used only when loading an old file generated with a version of bluebrick lower than 1.8.2, and that generated duplicated ids.
			// this second dictionnary will be used to temporary store the duplicated ids, and try to fix them after the loading.
			private static Dictionary<ulong, UniqueIdObjectPair> sHashtableForForDuplicatedIds = new Dictionary<ulong, UniqueIdObjectPair>();

			// We only need unique ids for the duration of the session. So we use an id counter, that is initialized to 0 when the Application starts,
			// then this counter is incremented everytime we need to create a new Unique Id.
			// Moreover, when we load a file, we set this counter to the maximum id that was loaded, so that future id created after load won't collide.
			// This is why it must be a long an not just an int (see the comment on mId)
			private static ulong sInstanceCounter = 0;

            public static readonly UniqueId Empty = new UniqueId(0);
            private UniqueId(ulong id)
            {
                mId = id;
            }

			/// <summary>
			/// The integer storing the id. The reason why it is a long and not an int, is because before the unique id
			/// were generated using the GetHashCode() which could have return a value close to int.MaxValue,
			/// therefore, all the following uniqueId instantiated would have potentially reboot the number.
			/// </summary>
            private ulong mId = 0;

			/// <summary>
			/// Default constructor of the UniqueId. This will initialized the unique id value from the
			/// instance counter, and will increase the instance counter, so that the next unique id constructed
			/// is guarantied to be unique.
			/// </summary>
            public UniqueId()
            {
				// increment the static counter
				sInstanceCounter++;
				// skip 0, as 0 is the special id for empty (no id). This may happen in case the number reboot.
				if (sInstanceCounter == 0)
					sInstanceCounter++;
				// give that value to the id encapsulated inside this class
				mId = sInstanceCounter;
            }

			/// <summary>
			/// Copy constructor. This copy the id, so that the two UniqueId have the same id.
			/// If you copy the UniqueId, we assume that you know what you are doing.
			/// </summary>
			/// <param name="copy">The UniqueId that should be copied.</param>
            public UniqueId(UniqueId copy)
            {
                mId = copy.mId;
            }

			/// <summary>
			/// Construct a unique id from the string given in parameter. This constructor is supposed to be called
			/// during the loading of a file, when we read the unique id from the file.
			/// </summary>
			/// <param name="stringId">A string representing an integer (int or long) that will be used as the unique id value of this instance</param>
            public UniqueId(string stringId)
            {
                // get the brick id as int
                mId = ulong.Parse(stringId);

				// If the loaded id is bigger than the counter, set the counter like this id so that the next created id will be just after this loaded one.
				if (mId > sInstanceCounter)
					sInstanceCounter = mId;
            }

			/// <summary>
			/// Serialize the id into a string. This is usefull when saving the file.
			/// </summary>
			/// <returns>a string representation of this id.</returns>
            public override string ToString()
            {
				return mId.ToString("D");
            }

			/// <summary>
			/// Return the object associated with this id in the hastable used during loading.
			/// If the object associated with this id is not of the correct specified type, 
			/// then this function return null.
			/// </summary>
			/// <typeparam name="T">The type of the object that should be associated with this id</typeparam>
			/// <returns>The object instance associated with this id, or null if there's no object associated, or if the object associated is of a different type.</returns>
            public T getObjectOfThatId<T>() where T : class
            {
				// try to get the obj from the dictionary
				object obj = null;
				sHashtableForRebuildingLinkAfterLoading.TryGetValue(mId, out obj);

				// cast it (this cast may make it null, which is ok)
				T objAsT = obj as T;

				// if we cannot find it (or if we find an object of the wrong type), try to get the object from the duplicated id dictionary
				if (objAsT == null)
				{
					UniqueIdObjectPair pair;
					if (sHashtableForForDuplicatedIds.TryGetValue(mId, out pair))
						objAsT = pair.mObject as T;
				}

				// return what we found (which can be null)
				return objAsT;
            }

			/// <summary>
			/// Associate the specified object with this id, and store this association in an Hashtable.
			/// This association is temporary and should only be used during the loading of the file.
			/// </summary>
			/// <param name="obj">The object instance to associate with this id.</param>
            public void associateWithThisObject(object obj)
            {
				try
				{
					// this is the normal case which normally should not fail. It can fail if the file loaded contains duplicated ids
					sHashtableForRebuildingLinkAfterLoading.Add(mId, obj);
				}
				catch
				{
					try
					{
						// if the file contains duplicated ids, try to save the id to another dictionary.
						// And if it is duplicated a second time, then we will loose the data, but without failing the loading
						sHashtableForForDuplicatedIds.Add(mId, new UniqueIdObjectPair(){ mUniqueId = this, mObject = obj } );
					}
					catch
					{
					}
				}
            }

			/// <summary>
			/// This method will clear the hastable used during the loading process.
			/// You should call this method everytime before loading a new file.
			/// This method will also try to fix the duplicated ids, if there was some found during loading.
			/// </summary>
            public static void ClearHashtableForLinkRebuilding()
            {
				// first try to fix the duplicated ids before clearing the hash table (if any)
				foreach (UniqueIdObjectPair pair in sHashtableForForDuplicatedIds.Values)
				{
					// increase the unique id, until we find a free space
					ulong newId = pair.mUniqueId.mId;
					do
					{
						newId++;
					}
					while (sHashtableForRebuildingLinkAfterLoading.ContainsKey(newId));
					
					// once we find a nice new id, modify the UniqueId class, and insert in the hastable (to avoid futur collision)
					pair.mUniqueId.mId = newId;
					sHashtableForRebuildingLinkAfterLoading.Add(newId, pair.mObject);
				}

				// now we can clear the hashtables
                sHashtableForRebuildingLinkAfterLoading.Clear();
				sHashtableForForDuplicatedIds.Clear();
            }
        }
        #endregion
        #region Entry point

        public static bool load(string filename)
		{
			string filenameLower = filename.ToLower();

			try
			{
				if (filenameLower.EndsWith("ldr") || filenameLower.EndsWith("dat"))
					return loadLDR(filename);
				else if (filenameLower.EndsWith("mpd"))
					return loadMDP(filename);
				else if (filenameLower.EndsWith("tdl"))
					return loadTDL(filename);
				else if (filenameLower.EndsWith("ncp"))
					return load4DBrix(filename);
				else if (filenameLower.EndsWith("bbb"))
					return loadBudgetBBB(filename);
				else
					return loadBBM(filename);
			}
			catch (Exception e)
			{
				string message = null;
				if (filenameLower.EndsWith("bbb"))
					message = Properties.Resources.ErrorMsgCannotOpenBudget.Replace("&", filename);
				else
					message = Properties.Resources.ErrorMsgCannotOpenMap.Replace("&", filename);
				LoadErrorForm errorMessageDialog = new LoadErrorForm(Properties.Resources.ErrorMsgTitleError, message, e.Message);
				errorMessageDialog.ShowDialog(MainForm.Instance);
				return false;
			}
		}

		public static bool save(string filename)
		{
			// first, check if the file is not read only (need to check that is exist, otherwise if we will create the file, we don't care)
			// need to check that is exist, because the read only flag is true if it doesn't exists
			FileInfo fileInfo = new FileInfo(filename);
			if (fileInfo.Exists && fileInfo.IsReadOnly)
			{
				MessageBox.Show(MainForm.Instance, BlueBrick.Properties.Resources.ErrorMsgReadOnlyFile.Replace("&", filename),
								BlueBrick.Properties.Resources.ErrorMsgTitleError, MessageBoxButtons.OK,
								MessageBoxIcon.Error, MessageBoxDefaultButton.Button1);
				return false;
			}

			// otherwise try to save it
			string filenameLower = filename.ToLower();
			try
			{
				if (filenameLower.EndsWith("ldr") || filenameLower.EndsWith("dat"))
					return saveLDR(filename);
				else if (filenameLower.EndsWith("mpd"))
					return saveMDP(filename);
				else if (filenameLower.EndsWith("tdl"))
					return saveTDL(filename);
				else if (filenameLower.EndsWith("ncp"))
					return save4DBrix(filename);
				else if (filenameLower.EndsWith("bbb"))
					return saveBudgetBBB(filename);
				else
					return saveBBM(filename);
			}
			catch (Exception e)
			{
				string message = null;
				if (filenameLower.EndsWith("bbb"))
					message = Properties.Resources.ErrorMsgCannotSaveBudget.Replace("&", filename);
				else
					message = Properties.Resources.ErrorMsgCannotSaveMap.Replace("&", filename);
				LoadErrorForm errorMessageDialog = new LoadErrorForm(Properties.Resources.ErrorMsgTitleError, message, e.Message);
				errorMessageDialog.ShowDialog(MainForm.Instance);
				return false;
			}
		}
		#endregion
		#region Budget Files

		private static bool loadBudgetBBB(string filename)
		{
			// create a serializer to load the map
			XmlSerializer mySerializer = new XmlSerializer(typeof(Budget.Budget));
			FileStream myFileStream = new FileStream(filename, FileMode.Open);
			// parse and copy the data into this
			Budget.Budget.Instance = mySerializer.Deserialize(myFileStream) as Budget.Budget;
			// release the file stream
			myFileStream.Close();
			myFileStream.Dispose();
			// the file can be open
			return true;
		}

		private static bool saveBudgetBBB(string filename)
		{
			// the current file name must be valid to call this function
			XmlSerializer mySerializer = new XmlSerializer(typeof(Budget.Budget));
			StreamWriter myWriter = new StreamWriter(filename, false);
			mySerializer.Serialize(myWriter, Budget.Budget.Instance);
			myWriter.Close();
			myWriter.Dispose();
			return true;
		}

		#endregion
		#region BlueBrick Format

		private static bool loadBBM(string filename)
		{
			// create a serializer to load the map
			XmlSerializer mySerializer = new XmlSerializer(typeof(Map));
			FileStream myFileStream = new FileStream(filename, FileMode.Open, FileAccess.Read);
			// By default init the progress bar from the size of the file
			// and divide by an approximate size value of a brick to 
			// have an estimation of the number of brick in the file.
			// This is only usefull for files which version is under 3, because
			// from version 3 we record the number of brick in the file
			MainForm.Instance.resetProgressBar((int)(myFileStream.Length / 900));
			// parse and copy the data into this
			Map.Instance = mySerializer.Deserialize(myFileStream) as Map;
            // recompute the absolute export file name, from the relative one saved in the BBM file
            // (and save temporarly in the absolute variable during the xml parsing)
            Map.Instance.computeAbsoluteExportPathAfterLoading(filename, Map.Instance.ExportAbsoluteFileName);
			// release the file stream
			myFileStream.Close();
			myFileStream.Dispose();
			// the file can be open
			return true;
		}

		private static bool saveBBM(string filename)
		{
			// the current file name must be valid to call this function
			XmlSerializer mySerializer = new XmlSerializer(typeof(Map));
			StreamWriter myWriter = new StreamWriter(filename, false);
			mySerializer.Serialize(myWriter, Map.Instance);
			myWriter.Close();
			myWriter.Dispose();
			return true;
		}

		#endregion
		#region LDRAW Format

		// for LDraw format we need to store the current group to add because to define the group a part belongs to
		// it uses two different lines in the LDraw file.
		private static Layer.Group mLDrawCurrentGroupInWhichAdd = null;
		private static readonly string LDRAW_DATE_FORMAT_STRING = "dd/MM/yyyy";
        private static Layer sCurrentLayerLoaded = null;
        private static string sCurrentLayerName = string.Empty;
        private static Hashtable sHashtableForGroupRebuilding = new Hashtable(); // this hashtable is used to recreate the group hierarchy when loading

        private static string[] splitLDrawLine(string line)
        {
            // split the searching filter in token
            // first we split the sentence by sub-sentence inside double quote for example: a "b c" d
            // will be split in 3: { 'a', 'b c', 'd' }
            // it's important to keep the empty entries in the split list because we want to catch cases like
            // the first character of the sentence is a double quote, or no space between two sub sentence:
            // "a b" c cc "d e""f g" => { '', 'a b', 'c cc', 'd e', '', 'f g' }
            //                            0     1       2      3    4     5
            // then we will split again even index, but not odd index, so split 0, 2, 4 ; keep 1, 3, 5
            char[] doubleQuoteSpliter = { '"' };
            string[] firstLevelTokenList = line.Split(doubleQuoteSpliter, StringSplitOptions.None);
            // now re-split only the even index with the empty char
            char[] spaceSpliter = { ' ', '\t' };
            List<string> tokenList = new List<string>();
            for (int i = 0; i < firstLevelTokenList.Length; ++i)
            {
                string firstLevelToken = firstLevelTokenList[i];
                // now if the current first level token is not empty
                if (firstLevelToken != string.Empty)
                {
                    // split Even index and directly add odd index
                    if ((i % 2) == 0)
                        tokenList.AddRange(firstLevelToken.Split(spaceSpliter, StringSplitOptions.RemoveEmptyEntries));
                    else
                        tokenList.Add(firstLevelToken);
                }
            }
            // return the array of token
            return tokenList.ToArray();
        }

		private static bool loadLDR(string filename)
		{
			// clear the hashmap used to load the groups
			sHashtableForGroupRebuilding.Clear();
			// create a new map
			Map.Instance = new Map();
			// open the file
			StreamReader textReader = new StreamReader(filename);
			// init the progress bar with the number of bytes of the file
			MainForm.Instance.resetProgressBar((int)(textReader.BaseStream.Length));
			// create a line spliter array
			while (!textReader.EndOfStream)
			{
				// read the current line
				string line = textReader.ReadLine();
				// move the progressbar according to the number of byte read
				MainForm.Instance.stepProgressBar(line.Length);
				// split the current line
                string[] token = splitLDrawLine(line);
				// check if the first token is 0 or 1, the other are just ignored
				if ((token[0] == "0") && (token.Length > 1))
				{
					// comment or meta command
					if (token[1].Equals("STEP"))
					{
						// new step, so finalize and add a layer then reset the pointer to make room for a new layer
                        finalizeCurrentLayerAndAddToMap();
					}
					else
					{
						parseMetaCommandLineLDRAW(line, token, 1, ref sCurrentLayerLoaded);
					}
				}
				else if (token[0] == "1")
				{
                    // cast the current layer
                    LayerBrick brickLayer = castOrGetANewCurrentLayerOfType<LayerBrick>();
                    // we are sure to have brick layer here
                    parseBrickLineLDRAW(token, 1, brickLayer);
				}
			}
			// close the stream
			textReader.Close();

			// finalize the last layer
            finalizeCurrentLayerAndAddToMap();

			// iterate on all the layers to recreate all the links between different items (after loading all the layers)
            foreach (Layer layer in Map.Instance.LayerList)
                layer.recreateLinksAfterLoading();

			// again clear the hashmap used to load the groups
			sHashtableForGroupRebuilding.Clear();

			// finish the progress bar (to hide it)
			MainForm.Instance.finishProgressBar();

			// the file can be open
			return true;
		}

		private static bool loadMDP(string filename)
		{
			// clear the hashmap used to load the groups
			sHashtableForGroupRebuilding.Clear();
			// create a new map
			Map.Instance = new Map();
			List<string> hiddenLayerNames = new List<string>();
			// open the file
			StreamReader textReader = new StreamReader(filename);
			// init the progress bar with the number of bytes of the file
			MainForm.Instance.resetProgressBar((int)(textReader.BaseStream.Length));
			// use a flag because in MPD, the first "0 FILE" tage is reserved for the file itself, the following one are the submodels
			bool wasFirstFileTagFound = false;
			// create a line spliter array
			while (!textReader.EndOfStream)
			{
				string line = textReader.ReadLine();
				// move the progressbar according to the number of byte read
				MainForm.Instance.stepProgressBar(line.Length);
				// split the current line
				string[] token = splitLDrawLine(line);
				// check if the first token is 0 or 1, the other are just ignored
				if ((token[0] == "0") && (token.Length > 1))
				{
					// comment or meta command
					if (token[1].Equals("FILE"))
					{
						if (wasFirstFileTagFound)
						{
							// new file, so add a layer (if the current layer is not empty)
							finalizeCurrentLayerAndAddToMap();
							// save the name the layer with the name of the sub model
							sCurrentLayerName = Path.GetFileNameWithoutExtension(line.Substring(7));
						}
						else
						{
							// we just ignore the first FILE command, it's just the file name of the file we are loading
							wasFirstFileTagFound = true;
						}
					}
					else if (token[1].Equals("STEP"))
					{
						// in mdp we skip the step
					}
					else if (token[1].Equals("MLCAD") && token[2].Equals("HIDE"))
					{
						// check if it is a sub model or a simple part hidden
						string partFullName = token[17];
						if (Path.GetExtension(partFullName.ToUpperInvariant()).Equals(".LDR"))
							hiddenLayerNames.Add(Path.GetFileNameWithoutExtension(partFullName));
						else
							parseMetaCommandLineLDRAW(line, token, 1, ref sCurrentLayerLoaded);
					}
					else
					{
						parseMetaCommandLineLDRAW(line, token, 1, ref sCurrentLayerLoaded);
					}
				}
				else if (token[0] == "1")
				{
                    // cast the current layer
                    LayerBrick brickLayer = castOrGetANewCurrentLayerOfType<LayerBrick>();
                    parseBrickLineLDRAW(token, 1, brickLayer);
				}
			}
			// close the stream
			textReader.Close();

            // finalize the last layer
            finalizeCurrentLayerAndAddToMap();

			// iterate on all the layers to hide the hidden ones we found
            foreach (Layer layer in Map.Instance.LayerList)
            {
                // also we need to recreate all the links between different items (after loading all the layers)
                layer.recreateLinksAfterLoading();
                foreach (string hiddenLayerName in hiddenLayerNames)
                    if (layer.Name.Equals(hiddenLayerName))
                    {
                        layer.Visible = false;
                        break;
                    }
            }

			// clear again the hashmap used to load the groups
			sHashtableForGroupRebuilding.Clear();

			// finish the progress bar (to hide it)
			MainForm.Instance.finishProgressBar();

			// the file can be open
			return true;
		}

        private static T castOrGetANewCurrentLayerOfType<T>() where T : Layer
        {
            // first check if we are the corresponding type, cast and return
            if ((sCurrentLayerLoaded != null) && !(sCurrentLayerLoaded is T))
            {
                // not the correct type, so finalize and reinit
                finalizeCurrentLayerAndAddToMap();
            }

            // create a new layer if needed
            if (sCurrentLayerLoaded == null)
            {
				if (typeof(T) == typeof(LayerBrick))
                    sCurrentLayerLoaded = new LayerBrick();
				else if (typeof(T) == typeof(LayerRuler))
                    sCurrentLayerLoaded = new LayerRuler();
				else if (typeof(T) == typeof(LayerGrid))
					sCurrentLayerLoaded = new LayerGrid();
				else if (typeof(T) == typeof(LayerText))
					sCurrentLayerLoaded = new LayerText();
				else if (typeof(T) == typeof(LayerArea))
					sCurrentLayerLoaded = new LayerArea();
                // set the name if not empty
                if (sCurrentLayerName != string.Empty)
                    sCurrentLayerLoaded.Name = sCurrentLayerName;
            }
            return (sCurrentLayerLoaded as T);
        }

        private static void finalizeCurrentLayerAndAddToMap()
        {
            if (sCurrentLayerLoaded != null)
            {
                // different finalization depending on the type
                if (sCurrentLayerLoaded is LayerBrick)
                {
                    if (sCurrentLayerLoaded.NbItems > 0)
                    {
                        LayerBrick brickLayer = sCurrentLayerLoaded as LayerBrick;
                        brickLayer.updateFullBrickConnectivity();
                        brickLayer.sortBricksByElevation();
                    }
                }

                // then add the layer to the map
                Map.Instance.addLayer(sCurrentLayerLoaded);

				// then clear the pointer
				sCurrentLayerLoaded = null;
			}
        }

		private static void checkIfItemMustBeAddedToGroup(Layer.LayerItem item)
		{
			// if the mLDrawCurrentGroupInWhichAdd is not null that means a "MLCAD BTG" was found in the previous line of the file
			// so we need to add the current brick (or group) to the group specified in the "MLCAD BTG" and then
			// we clear the reference
			if (mLDrawCurrentGroupInWhichAdd != null)
			{
				// add the item to the group
				mLDrawCurrentGroupInWhichAdd.addItem(item);
				// clear the reference, a new "MLCAD BTG" command must be find again
				mLDrawCurrentGroupInWhichAdd = null;
			}
		}

		private static string getGroupNameForSaving(Layer.Group group)
		{
			// return the part number followed by the hash code
			// the part number is needed at loading time to ask the part lib if this group can be split
			// the hash code is needed to make unique group name
			return group.PartNumber + "#" + ((group != null) ? group.GUID.ToString() : SaveLoadManager.UniqueId.Empty.ToString());
		}

		private static Layer.Group createOrGetGroup(string groupName)
		{
			// look in the hastable if this group alread exists, else create it
			Layer.Group group = sHashtableForGroupRebuilding[groupName] as Layer.Group;
			if (group == null)
			{
				// remove the unique hash code at the end of the the group name to get only the part number
				// and ask to the part lib if it is an non ungroupable group
				bool canUngroup = true;
				int hashCodeIndex = groupName.LastIndexOf('#');
				if (hashCodeIndex > 0)
				{
					string partNumber = groupName.Substring(0, hashCodeIndex);
					if (partNumber != string.Empty)
						canUngroup = BrickLibrary.Instance.canUngroup(partNumber);
				}
				// instanciate a new group, and add it in the hash table
				group = new Layer.Group(canUngroup);
				// then add the group in the hash table
				sHashtableForGroupRebuilding.Add(groupName, group);
			}
			// return the group
			return group;
		}

		private static string getRemainingOfLineAfterTokenInLDRAW(string line, string token)
		{
			return line.Substring(line.IndexOf(token) + token.Length).Trim();
		}

		private static void parseDateInLDRAW(string dateToParse)
		{
			try
			{
				DateTime date = DateTime.ParseExact(dateToParse, LDRAW_DATE_FORMAT_STRING, System.Globalization.CultureInfo.InvariantCulture);
				Map.Instance.Date = date;
			}
			catch (Exception)
			{
			}
		}

		private static void parseMetaCommandLineLDRAW(string line, string[] token, int startIndex, ref Layer currentLayer)
		{
			if (token[startIndex].StartsWith("Author"))
			{
				Map.Instance.Author = getRemainingOfLineAfterTokenInLDRAW(line, token[1]);
			}
			else if (token[startIndex].StartsWith("Lug"))
			{
				Map.Instance.LUG = getRemainingOfLineAfterTokenInLDRAW(line, token[1]);
			}
			else if (token[startIndex].StartsWith("Event"))
			{
				Map.Instance.Event = getRemainingOfLineAfterTokenInLDRAW(line, token[1]);
			}
			else if (token[startIndex].StartsWith("Date"))
			{
				parseDateInLDRAW(getRemainingOfLineAfterTokenInLDRAW(line, token[1]));
			}
			else if (token[startIndex].StartsWith("//"))
			{
				if (token[startIndex + 1].StartsWith("LUG"))
					Map.Instance.LUG = getRemainingOfLineAfterTokenInLDRAW(line, token[2]);
				else if (token[startIndex + 1].StartsWith("Event"))
					Map.Instance.Event = getRemainingOfLineAfterTokenInLDRAW(line, token[2]);
				else if (token[startIndex + 1].StartsWith("Date"))
					parseDateInLDRAW(getRemainingOfLineAfterTokenInLDRAW(line, token[2]));
				else
				{
					// add the comment in the comment line
					string comment = Map.Instance.Comment;
					comment += line.Substring(5) + Environment.NewLine;
					Map.Instance.Comment = comment;
				}
			}
			else if (token[startIndex].Equals("MLCAD"))
			{
				if (token[startIndex + 1].Equals("HIDE"))
				{
                    if (token[startIndex + 2].Equals("0"))
                    {
                        parseMetaCommandLineLDRAW(line, token, startIndex + 3, ref currentLayer);
                    }
                    else if (token[startIndex + 2].Equals("1"))
                    {
                        LayerBrick brickLayer = castOrGetANewCurrentLayerOfType<LayerBrick>();
					    parseBrickLineLDRAW(token, startIndex + 3, brickLayer);
                    }
					currentLayer.Visible = false;
				}
				else if (token[startIndex + 1].Equals("BTG"))
				{
					// the meta command is: 0 MLCAD BTG <group name>
					// get the group (or create it) and store it in the current group variable
					string groupName = line.Substring(line.IndexOf(token[3])).Trim();
					mLDrawCurrentGroupInWhichAdd = createOrGetGroup(groupName);
				}
			}
			else if (token[startIndex].Equals("GROUP"))
			{
				// the meta command from MLCAD is: 0 GROUP <item count> <group name>
				string groupName = line.Substring(line.IndexOf(token[3])).Trim();
				Layer.Group group = createOrGetGroup(groupName);
				checkIfItemMustBeAddedToGroup(group);
			}
            else if (token[startIndex].Equals("!BLUEBRICK"))
            {
                // get the version of the comman
                int commandVersion = int.Parse(token[startIndex + 2]);
                // parse the command
                if (token[startIndex + 1].Equals("RULER"))
                {
                    LayerRuler rulerLayer = castOrGetANewCurrentLayerOfType<LayerRuler>();
                    parseRulerLineLDRAW(token, startIndex + 3, rulerLayer, commandVersion);
                }
            }

			// skip all the rest of unknown meta commands
		}

		private static void parseBrickLineLDRAW(string[] token, int startIndex, LayerBrick currentLayer)
		{
			// only parse the DAT part, if the part is a ldr (i.e submodel, we just skip it)
			string partFullName = token[startIndex + 13];
			if (!Path.GetExtension(partFullName.ToUpperInvariant()).Equals(".DAT"))
				return;

			try
			{
				string color = token[startIndex++];
				float x = float.Parse(token[startIndex++], System.Globalization.CultureInfo.InvariantCulture);
				float y = float.Parse(token[startIndex++], System.Globalization.CultureInfo.InvariantCulture);
				float z = -float.Parse(token[startIndex++], System.Globalization.CultureInfo.InvariantCulture);
				float a = float.Parse(token[startIndex++], System.Globalization.CultureInfo.InvariantCulture);
				startIndex++; // skip b
				float c = float.Parse(token[startIndex++], System.Globalization.CultureInfo.InvariantCulture);
				startIndex += 6; // skip d f g h i j
				string partNumberWithoutColor = Path.GetFileNameWithoutExtension(partFullName).ToUpperInvariant();
				string partNumber = partNumberWithoutColor + "." + color;

				// check if it is a sleeper that we should ignore
				if (BrickLibrary.Instance.shouldBeIgnoredAtLoading(partNumber))
					return;

				// compute the orientation angle
				float angle = (float)Math.Atan2(c, a);
				// compute the angle in degree
				angle *= (float)(180.0 / Math.PI);

				// check if we have some origin conversion to do
				BrickLibrary.Brick.LDrawRemapData remapData = BrickLibrary.Instance.getLDrawRemapData(partNumber);
				if (remapData != null)
				{
					// cheat the angle
					angle -= remapData.mAngle;
					// add a shift in the good direction
					if ((remapData.mTranslation.X != 0.0f) || (remapData.mTranslation.Y != 0.0f))
					{
						Matrix rotation = new Matrix();
						rotation.Rotate(angle);
						PointF[] offset = { new PointF(-remapData.mTranslation.X, remapData.mTranslation.Y) };
						rotation.TransformVectors(offset);
						x += offset[0].X;
						z += offset[0].Y;
					}
				}

				// create a new brick
				LayerBrick.Brick brick = new LayerBrick.Brick(BrickLibrary.Instance.getActualPartNumber(partNumber));

				// rotate the brick (will recompute the correct OffsetFromOriginalImage)
				brick.Orientation = angle;

				// rescale the position because 1 stud = 20 LDU and set the center position
				x = (x / 20.0f) - brick.OffsetFromOriginalImage.X;
				z = (z / 20.0f) - brick.OffsetFromOriginalImage.Y;
				brick.Center = new PointF(x, z);
				brick.Altitude = y;

				// add the brick to the layer
				currentLayer.addBrick(brick, -1);

				// check if we need to add this brick to a group
				checkIfItemMustBeAddedToGroup(brick);
			}
			catch (Exception)
			{
			}
		}

        private static void parseRulerLineLDRAW(string[] token, int startIndex, LayerRuler currentLayer, int commandVersion)
        {
            // create a new ruler depending on the type
            LayerRuler.RulerItem ruler = null;
            if (token[startIndex++].Equals("LINEAR"))
                ruler = new LayerRuler.LinearRuler();
            else
                ruler = new LayerRuler.CircularRuler();
            // the call the serialization
            ruler.ReadLDraw(token, ref startIndex, commandVersion);
            // add the ruler to the layer
            currentLayer.addRulerItem(ruler, -1);
            // check if we need to add this brick to a group
            checkIfItemMustBeAddedToGroup(ruler);
        }

		private static bool saveLDR(string filename)
		{
			// init the progress bar with the number of items (+1 for init remap +1 for header so start with 2)
			int nbItems = 2;
			foreach (Layer layer in Map.Instance.LayerList)
				nbItems += layer.NbItems;
			MainForm.Instance.resetProgressBar(nbItems);

			// step the progressbar after the init of part remap
			MainForm.Instance.stepProgressBar();

			StreamWriter textWriter = new StreamWriter(filename, false, new UTF8Encoding(false));
			// write the header
			saveHeaderInLDRAW(textWriter);
			// add a line break
			textWriter.WriteLine("0");
			// step the progressbar after the write of the header
			MainForm.Instance.stepProgressBar();

			// iterate on all the layers of the Map
			foreach (Layer layer in Map.Instance.LayerList)
			{
                // save the layer according its type
                saveLayerInLDRAW(textWriter, layer, true);
				// add a step to separate the layers
				textWriter.WriteLine("0 STEP");
			}
			// close the file
			textWriter.Close();
			return true;
		}

		private static bool saveMDP(string filename)
		{
			// init the progress bar with the number of items (+1 for init remap +2 for header, start with 3)
			int nbItems = 3;
			foreach (Layer layer in Map.Instance.LayerList)
    			nbItems += layer.NbItems;
			MainForm.Instance.resetProgressBar(nbItems);

			// step the progressbar after the init of part remap
			MainForm.Instance.stepProgressBar();

			StreamWriter textWriter = new StreamWriter(filename, false, new UTF8Encoding(false));
			// in mpd, we always start with the 0 FILE command,
			// and we start with the main model that contains all the layers
			textWriter.WriteLine("0 FILE " + Path.GetFileNameWithoutExtension(filename) + ".ldr");
			// write the header
			saveHeaderInLDRAW(textWriter);
			// step the progressbar after the write of the header
			MainForm.Instance.stepProgressBar();

			// write the list of all the layer, at the 0 position with identity matrix in black
			// the format line is like for a single part:
			// 1 <colour> x y z a b c d e f g h i <file> 
			// the black color has the code 1, the <file> is the name of the layer, replacing the space by _
			List<string> layerStandardizedNames = new List<string>(Map.Instance.LayerList.Count);
			foreach (Layer layer in Map.Instance.LayerList)
			{
				// compute the clean layer name, removing white character
				string layerName = layer.Name.Trim().Replace(' ', '_');
				layerName = layerName.Replace('\t', '_');
				layerName += ".ldr";
				// write the line of the part
				string line = "";
				if (!layer.Visible)
                    line += LDrawReadWrite.MLCAD_COMMAND_HIDE;
				line += "1 1 0 0 0 1 0 0 0 1 0 0 0 1 " + layerName;
				textWriter.WriteLine(line);
				// add the name in the list for later use
				layerStandardizedNames.Add(layerName);
			}
			// step the progressbar after the write of the layer list
			MainForm.Instance.stepProgressBar();

			// add a line break
			textWriter.WriteLine("0");
			// iterate on all the layers of the Map
			int layerIndex = 0;
			foreach (Layer layer in Map.Instance.LayerList)
			{
				// write the file meta command with the same name computed before for the layer
				textWriter.WriteLine("0 FILE " + layerStandardizedNames[layerIndex++]);
				// write a small header, but not the full info, just the type and author
				textWriter.WriteLine("0 Author: " + Map.Instance.Author);
				textWriter.WriteLine("0 Unofficial Model");
				textWriter.WriteLine("0");
				// write the content of the layer
                saveLayerInLDRAW(textWriter, layer, false);
				// add a line break
				textWriter.WriteLine("0");
			}
			// close the file
			textWriter.Close();
			return true;
		}

		private static void saveHeaderInLDRAW(StreamWriter textWriter)
		{
			// the first 0 line should be the file description (so we use the file name without extension)
			textWriter.WriteLine("0 " + Path.GetFileNameWithoutExtension(Map.Instance.MapFileName));
			textWriter.WriteLine("0 Name: " + Path.GetFileName(Map.Instance.MapFileName));
			textWriter.WriteLine("0 Author: " + Map.Instance.Author);
			textWriter.WriteLine("0 Unofficial Model");
			// write other global infos of this file
			textWriter.WriteLine("0");
			textWriter.WriteLine("0 // LUG: " + Map.Instance.LUG);
			textWriter.WriteLine("0 // Event: " + Map.Instance.Event);
			textWriter.WriteLine("0 // Date: " + Map.Instance.Date.ToString(LDRAW_DATE_FORMAT_STRING, System.Globalization.CultureInfo.InvariantCulture));
			// write the comments of this map
			char[] commentSpliter = { '\r', '\n' };
			String[] commentLines = Map.Instance.Comment.Split(commentSpliter);
			foreach (string commentLine in commentLines)
				if (commentLine != string.Empty)
					textWriter.WriteLine("0 // " + commentLine);
			// add one spaced line
			textWriter.WriteLine("0");
		}

        private static void saveLayerInLDRAW(StreamWriter textWriter, Layer layer, bool useMLCADHide)
        {
            // check the type because we only save brick layers
            if (layer is LayerBrick)
                saveBrickLayerInLDRAW(textWriter, layer as LayerBrick, useMLCADHide);
            else if (layer is LayerRuler)
                saveRulerLayerInLDRAW(textWriter, layer as LayerRuler, useMLCADHide);
            else if (layer is LayerArea)
                saveAreaLayerInLDRAW(textWriter, layer as LayerArea, useMLCADHide);
            else if (layer is LayerGrid)
                saveGridLayerInLDRAW(textWriter, layer as LayerGrid, useMLCADHide);
            else if (layer is LayerText)
                saveTextLayerInLDRAW(textWriter, layer as LayerText, useMLCADHide);
        }

		private static void saveBrickLayerInLDRAW(StreamWriter textWriter, LayerBrick brickLayer, bool useMLCADHide)
		{
			// clear the group list for saving
			Layer.Group.sListForGroupSaving.Clear();

			// check if the layer is hidden (and so we should hide all the bricks)
			bool hideBricks = useMLCADHide && !brickLayer.Visible;

			// declare a list to store all the connection point for which the sleepers where already added
			List<LayerBrick.Brick.ConnectionPoint> addedSleepers = new List<LayerBrick.Brick.ConnectionPoint>();

			// iterate on all the bricks
			foreach (LayerBrick.Brick brick in brickLayer.BrickList)
			{
				// step the progressbar for each brick (we do it at the begining because there is a continue in this loop)
				MainForm.Instance.stepProgressBar();

				// split the part name and color
				string[] partNumberAndColor = { string.Empty, string.Empty };
				int lastDotIndex = brick.PartNumber.LastIndexOf('.');
				if (lastDotIndex >= 0)
				{
					partNumberAndColor[0] = brick.PartNumber.Substring(0, lastDotIndex);
					partNumberAndColor[1] = brick.PartNumber.Substring(lastDotIndex + 1);
				}
				else
				{
					partNumberAndColor[0] = brick.PartNumber;
				}
				// skip the brick if it is a set, a logo, or a special custom part
				// so we skip all the parts that don't have a valid color number
				int intColor = 0;
				if ((partNumberAndColor[1] == string.Empty) || !int.TryParse(partNumberAndColor[1], out intColor))
					continue;

				// compute x and y because the pair bricks doesn't have image in the library
				float x = brick.Center.X + brick.OffsetFromOriginalImage.X;
				float z = -brick.Center.Y - brick.OffsetFromOriginalImage.Y;

				// get the remap data
				BrickLibrary.Brick.LDrawRemapData remapData = BrickLibrary.Instance.getLDrawRemapData(brick.PartNumber);

				// check if we need to save another brick number instead
				if (remapData != null)
				{
					if (remapData.mAliasPartNumber != null)
						partNumberAndColor[0] = remapData.mAliasPartNumber;
					if (remapData.mAliasPartColor != null)
						partNumberAndColor[1] = remapData.mAliasPartColor;
				}

				// save the brick
				saveOneBrickInLDRAW(textWriter, brick, partNumberAndColor, x, z, remapData, hideBricks);

				// if there's no remap for this brick, just continue to next brick
				if (remapData == null)
					continue;

				// check if we need to add sleepers
				if ((remapData.mSleeperBrickNumber != null) && (brick.HasConnectionPoint))
				{
					// this is a rail brick, we need to add 2 sleepers
					// save the sleeper brick name into the part number array
					partNumberAndColor[0] = remapData.mSleeperBrickNumber;
					partNumberAndColor[1] = remapData.mSleeperBrickColor;
					// and create a temp brick for saving
					LayerBrick.Brick sleeperBrick = new LayerBrick.Brick(partNumberAndColor[0] + "." + partNumberAndColor[1]);
					sleeperBrick.Altitude = brick.Altitude;

					// get the remap data of the sleeper
					BrickLibrary.Brick.LDrawRemapData sleeperRemapData = BrickLibrary.Instance.getLDrawRemapData(sleeperBrick.PartNumber);

					// if we found the sleeper remap data, add the difference of height between the rail brick and the sleeper
					if ((sleeperRemapData != null) && (sleeperBrick.Altitude != 0.0f))
						sleeperBrick.Altitude += sleeperRemapData.mPreferredHeight - remapData.mPreferredHeight;

					// first check the connections points (the two extremity of the rail)
					int nbConnexions = brick.ConnectionPoints.Count;
					for (int i = 0; i < nbConnexions; ++i)
					{
						// get the current connexion
						LayerBrick.Brick.ConnectionPoint connexion = brick.ConnectionPoints[i];
						// if the connexion is free we need to add the sleeper
						// else if it is not free we check if we didn't already add it or if we should add it's neighboor
						// by default we will add the sleeper, and find the false cases
						bool needToAddSleeper = true;
						// first check if the connexion is not free
						if (!connexion.IsFree)
						{
							// if the track is connected we check if we didn't already added the sleeper (if yes we don't need to add it)
							if (addedSleepers.Contains(connexion.ConnectionLink))
							{
								// no need to add the sleeper, it's already done
								needToAddSleeper = false;
							}
							else
							{
								// if we didn't already add the sleeper then we need to check if the current sleeper
								// is of type gray 12V (those with clip) because if the other sleeper is a normal
								// 2x8 plate, then we don't add it, we will add the plate instead
								if (remapData.mSleeperBrickNumber.Equals("767"))
								{
									BrickLibrary.Brick.LDrawRemapData connectedBrickRemapData = BrickLibrary.Instance.getLDrawRemapData(connexion.ConnectedBrick.PartNumber);
									if ((connectedBrickRemapData != null) && (connectedBrickRemapData.mSleeperBrickNumber != null))
										needToAddSleeper = (connectedBrickRemapData.mSleeperBrickNumber.Equals("767"));
								}
							}
						}
						// now add the sleeper if we need to
						if (needToAddSleeper)
						{
							// set the correct position and orientation of the sleeper
							sleeperBrick.Orientation = brick.Orientation + BrickLibrary.Instance.getConnectionAngle(brick.PartNumber, i);
							x = connexion.PositionInStudWorldCoord.X;
							z = -connexion.PositionInStudWorldCoord.Y;
							saveOneBrickInLDRAW(textWriter, sleeperBrick, partNumberAndColor, x, z, sleeperRemapData, hideBricks);
							// add the brick to the list (to avoid adding another sleeper at the same place)
							addedSleepers.Add(connexion);
						}
					}
				}
			}

			// now save the groups if we found some
			foreach (Layer.Group group in Layer.Group.sListForGroupSaving)
				saveOneGroupInLDRAW(textWriter, group, hideBricks);
			// and clear the group list for saving
			Layer.Group.sListForGroupSaving.Clear();
		}

		private static void saveOneBrickInLDRAW(StreamWriter textWriter, LayerBrick.Brick brick, string[] partNumberAndColor, float x, float z, BrickLibrary.Brick.LDrawRemapData remapData, bool hideBricks)
		{
			// the LDRAW format for a brick is:
			// 1 <colour> x y z a b c d e f g h i <file> 
			// where x y z is the position and a b c d e f g h i is the matrix
			// in BlueBrick the color is contained in the name of the part number
			// the position must be translated from stud to LDU (1 stud = 20 LDU),
			// and the Y coord is from the altitude of the brick (0 by default)
			// The matrix is the identity, except if you rotate the part, but
			// the second line of the matrix is always the identity
			// GROUPED BRICK:
			// If the brick is part of a group, MLCAD introduced two commands.
			// The line "0 MLCAD BTG <my group name>" should be placed before the brick
			// to indicate that the brick Belongs To the Group (BTG)
			// the line "0 GROUP <Num items> <group name>" should be placed where the group
			// should appear

			// first check if this brick belongs to a group
			if (brick.Group != null)
			{
				textWriter.WriteLine(LDrawReadWrite.MLCAD_COMMAND_BTG + getGroupNameForSaving(brick.Group));
				// add this group to the temporary list for saving if not already done
				if (!Layer.Group.sListForGroupSaving.Contains(brick.Group))
					Layer.Group.sListForGroupSaving.Add(brick.Group);
			}

			// the position of the brick
			x *= 20;
			float y = brick.Altitude;
			z *= 20;
			// angle
			float angle = brick.Orientation;

			// check if we have some origin conversion to do
			if (remapData != null)
			{
				// add a shift in the good direction
				if ((remapData.mTranslation.X != 0.0f) || (remapData.mTranslation.Y != 0.0f))
				{
					Matrix rotation = new Matrix();
					rotation.Rotate(-angle);
					PointF[] offset = { new PointF(remapData.mTranslation.X, remapData.mTranslation.Y) };
					rotation.TransformVectors(offset);
					x += offset[0].X;
					z += offset[0].Y;
				}
				// set the height if there's not already a non null height set
				if (y == 0.0f)
					y = remapData.mPreferredHeight;
				// cheat the angle
				angle += remapData.mAngle;
			}

			// construct the line
			string line = "";
			// first the visible if we should use it
			if (hideBricks)
                line += LDrawReadWrite.MLCAD_COMMAND_HIDE;
			// then the type and color
			line += "1 " + partNumberAndColor[1];
			// position
			line += " " + x.ToString(System.Globalization.CultureInfo.InvariantCulture);
			line += " " + y.ToString(System.Globalization.CultureInfo.InvariantCulture);
			line += " " + z.ToString(System.Globalization.CultureInfo.InvariantCulture);
			// matrix
			// convert the angle in radian
			angle *= (float)Math.PI / 180.0f;
			float cosAngle = (float)Math.Cos(angle);
			float sinAngle = (float)Math.Sin(angle);
			string cosAngleStr = cosAngle.ToString(System.Globalization.CultureInfo.InvariantCulture);
			string sinAngleStr = sinAngle.ToString(System.Globalization.CultureInfo.InvariantCulture);
			string minusSinAngleStr = (-sinAngle).ToString(System.Globalization.CultureInfo.InvariantCulture);
			line += " " + cosAngleStr + " 0 " + sinAngleStr;
			line += " 0 1 0";
			line += " " + minusSinAngleStr + " 0 " + cosAngleStr;
			// file
			line += " " + partNumberAndColor[0] + ".DAT";
			//write the line
			textWriter.WriteLine(line);
		}

		private static void saveOneGroupInLDRAW(StreamWriter textWriter, LayerBrick.Group group, bool hideGroup)
		{
			// the MLCAD format for a group is:
			// "0 GROUP <Num items> <group name>"
			// it should be placed where the group should appear
			// start to construct the line
			// If the brick is part of a group, MLCAD introduced two commands.
			// The line "0 MLCAD BTG <my group name>" should be placed before the brick
			// to indicate that the brick Belongs To the Group (BTG)

			// first check if this group belongs to a group
			if (group.Group != null)
                textWriter.WriteLine(LDrawReadWrite.MLCAD_COMMAND_BTG + getGroupNameForSaving(group.Group));

			string line = "";
			// first the visible if we should use it
			if (hideGroup)
                line += LDrawReadWrite.MLCAD_COMMAND_HIDE;

			// group meta command and number of items and group unique name
            line += LDrawReadWrite.COMMON_COMMAND_GROUP + group.ItemsCount.ToString() + " " + getGroupNameForSaving(group);
			//write the line
			textWriter.WriteLine(line);
		}

		private static void saveRulerLayerInLDRAW(StreamWriter textWriter, LayerRuler rulerLayer, bool useMLCADHide)
		{
			// clear the group list for saving
			Layer.Group.sListForGroupSaving.Clear();

			// check if the layer is hidden (and so we should hide all the bricks)
			bool hideRulers = useMLCADHide && !rulerLayer.Visible;

			// iterate on all the bricks
			foreach (LayerRuler.RulerItem ruler in rulerLayer.RulerList)
			{
				// step the progressbar for each brick (we do it at the begining because there is a continue in this loop)
				MainForm.Instance.stepProgressBar();
				// save the ruler
				saveOneRulerItemInLDRAW(textWriter, ruler, hideRulers);
			}

			// now save the groups if we found some
			foreach (Layer.Group group in Layer.Group.sListForGroupSaving)
				saveOneGroupInLDRAW(textWriter, group, hideRulers);
			// and clear the group list for saving
			Layer.Group.sListForGroupSaving.Clear();
		}

		private static void saveOneRulerItemInLDRAW(StreamWriter textWriter, LayerRuler.RulerItem ruler, bool hideRulers)
		{
			// the LDRAW format for a ruler is:
            // 0 !BLUEBRICK RULER <version> <type> <id> <DisplayDistance> <DisplayUnit> <color> <GuidelineColor> <MeasureFontColor> <LineThickness> <GuidelineThickness> <GuidelineDashPattern> <Unit> <FontFamily|Size|Style> <geometry>
			// where <version> is an int describing the current version of the command
			// <type> is LINEAR or CIRCULAR
            // <id> is a hash code with a '#' prefix
			// <DisplayDistance> <DisplayUnit> are bool in form of an int 0 or 1
			// <color> <GuidelineColor> <MeasureFontColor> are colors in hex format AARRGGBB
			// <LineThickness> <GuidelineThickness> are float in pixel
			// <GuidelineDashPattern> is float separted by semicolon representing "space-dash" in percentage of GuidelineThickness
			// <Unit> is an int for that order
			// <MeasureFont> is a triplet in double quote representing the font family name, the size and the style
			// <geometry> depends on the type
			//		for linear:
			//		for circular:
			// GROUPED BRICK:
			// If the ruler is part of a group, MLCAD introduced two commands.
			// The line "0 MLCAD BTG <my group name>" should be placed before the ruler
			// to indicate that the brick Belongs To the Group (BTG)
			// the line "0 GROUP <Num items> <group name>" should be placed where the group
			// should appear

			// first check if this ruler belongs to a group
			if (ruler.Group != null)
			{
                textWriter.WriteLine(LDrawReadWrite.MLCAD_COMMAND_BTG + getGroupNameForSaving(ruler.Group));
				// add this group to the temporary list for saving if not already done
				if (!Layer.Group.sListForGroupSaving.Contains(ruler.Group))
					Layer.Group.sListForGroupSaving.Add(ruler.Group);
			}

			string line = "";
			// first the visible if we should use it
			if (hideRulers)
				line += LDrawReadWrite.MLCAD_COMMAND_HIDE;

			// meta command for BB Ruler
            line += LDrawReadWrite.BB_COMMAND_RULER;
            // the call the serialization
            ruler.WriteLDraw(ref line);

			//write the line
			textWriter.WriteLine(line);
		}

		private static void saveAreaLayerInLDRAW(StreamWriter textWriter, LayerArea areaLayer, bool useMLCADHide)
		{
			textWriter.WriteLine("0 // Area layer not implemented yet, see you maybe in BB 1.9");
            MainForm.Instance.stepProgressBar(areaLayer.NbItems);
        }

		private static void saveGridLayerInLDRAW(StreamWriter textWriter, LayerGrid gridLayer, bool useMLCADHide)
		{
            textWriter.WriteLine("0 // Grid layer not implemented yet, see you maybe in BB 1.9");
            MainForm.Instance.stepProgressBar(gridLayer.NbItems);
        }

		private static void saveTextLayerInLDRAW(StreamWriter textWriter, LayerText textLayer, bool useMLCADHide)
		{
            textWriter.WriteLine("0 // Text layer not implemented yet, see you maybe in BB 1.9");
            MainForm.Instance.stepProgressBar(textLayer.NbItems);
        }
		#endregion
		#region TrackDesigner Format

		private static bool loadTDL(string filename)
		{
			// create a new map and different layer for different type of parts
			Map.Instance = new Map();
			LayerBrick baseplateLayer = new LayerBrick();
			LayerBrick rail9VLayer = new LayerBrick();
			LayerBrick monorailLayer = new LayerBrick();
			LayerBrick currentLayer = baseplateLayer;

			// declare a bool to check if we found some part not remaped in the remap file
			List<int> noRemapablePartFound = new List<int>();

			// update the registry to use
			BrickLibrary.Instance.updateCurrentTrackDesignerRegistryUsed();

			// open the file
			FileStream myFileStream = new FileStream(filename, FileMode.Open, FileAccess.Read);
			BinaryReader binaryReader = new BinaryReader(myFileStream);
			// init the progress bar with the number of bytes of the file
			MainForm.Instance.resetProgressBar((int)(myFileStream.Length));

			// read the header which is 124 bytes normally without comments
			int headerSize = loadTDLHeader(binaryReader);
			// check if there was an error reading the TD header
			if (headerSize <= 0)
			{
				// finish the progressbar to hide it
				MainForm.Instance.finishProgressBar();
				binaryReader.Close();
				myFileStream.Close();
				return false;
			}

			// read the number of CTrackPieces in the list of parts
			int nbTrackPieces = binaryReader.ReadInt16();
			headerSize += 2;
			// read the header of the CTrackPieces list (containing the string "CTrackPiece")
			binaryReader.ReadChars(17);
			headerSize += 17;

			// move the progressbar according to the number of byte read
			MainForm.Instance.stepProgressBar(headerSize);

			// read until we reach the end of file
			bool endOfFile = (binaryReader.BaseStream.Position >= binaryReader.BaseStream.Length);
			while (!endOfFile)
			{
				// The part number (that contains the class of the part) and separate the number and the class
				// The class are like that:
				//             0 = baseplate
				//       100 000 = 9Vtrain,  except 9V crossover is 1 000 100 000 and train station set is 110 000
				//       200 000 = monorail
				//       300 000 = road
				//       4x0 000 = 12V gray rail where x is 1 or 3
				//       5x0 000 = 4.5V gray rail where x is 0 or 3
				//       6x0 000 = 12V blue rail where x is 1 or 3
				//       7x0 000 = 4.5V blue rail where x is 0 or 3
				//       800 000 = road
				//       900 000 = road (green) except one part is 10 900 000
				//     1 000 000 = road (green)
				//    11 000 000 = road (green)
				// 1 0x0 000 000 = support where x is from 1 to 7
				int TDPartNumber = binaryReader.ReadInt32();

				// skip the pointer in memory (also used as an instance ID)
				binaryReader.ReadInt32();

				// read angle in degree
				double angle = binaryReader.ReadDouble();
				// read x in stud
				double x = binaryReader.ReadDouble();
				// read y in stud
				double y = binaryReader.ReadDouble();
				// skip z (also a double), the value is multiplied by 3 compared to the value displayed in TrackDesigner
				double z = binaryReader.ReadDouble();

				// le type de la pice (an int) (0 = Straight, 1 = Left Curve, 2 = Right Curve, 3 = Left Split, 4 = Right Split, 5 = Left Merge, 6 = Right Merge, 7 = Left Join, 8 = Right Join, 9 = Crossover, 10 = T Junction, 11 = Up Ramp, 12 = Down Ramp, 13 = Short Straight, 14 = Short Left Curve In, 15 = Short Right Curve In, 16 = Short Left Curve Out, 17 = Short Right Curve Out, 18 = Left Reverse Switch, 19 = Right Reverse Switch, 20 = Custom)
				int type = binaryReader.ReadInt32();

				// the id of bitmap (an int) when a part (like a curve) has two bitmap in the TrackDesigner part library, or for two baseplase with different color
				int portIdOfOrigin = binaryReader.ReadInt32();

				// skip 4 structures for the connexion, each structure is made of:
				// - a pointer (instance ID)
				// - a int that is the Port number connected to on other piece
				// - a int that is the Port polarity: 0 unasasigned, 2 -ve, 3 +ve
				// = so it is 4*3*4 = 48 bytes
				// then skip also:
				// - a int that is flags
				// - a int that is slope 
				// + one word (2 bytes that I don't know the meaning maybe comming from the list) = 10 bytes
				// Note: the 2 bytes are not present for the last part in the stream, so for the last part we should skip less bytes
				long remainingBytesCount = binaryReader.BaseStream.Length - binaryReader.BaseStream.Position;
				if (remainingBytesCount >= 58)
					binaryReader.ReadBytes(58);
				else
					endOfFile = true;

				// --------------

				// special case for a down ramp (TD give to the up and down ramp the same id with different bitmap id)
				// whereas in fact it is two different parts.
				if ((TDPartNumber == 232677) && (portIdOfOrigin == 1))
					TDPartNumber = 232678;

				// try to get the remap data for the BlueBrick part number
				string BBPartNumber = null;
				BrickLibrary.Brick.TDRemapData remapData = BrickLibrary.Instance.getTDRemapData(TDPartNumber, out BBPartNumber);

				// if it is a valid part, get the class of the brick to know in which layer add
				// and then create the brick and add it to the layer
				if (remapData != null)
				{
					// create a new brick
					LayerBrick.Brick brick = new LayerBrick.Brick(BBPartNumber);

					// choose the corect layer according to the type of connexion
					if (brick.HasConnectionPoint)
					{
						// this switch is hard-coded, it should be refactored
						switch (brick.ConnectionPoints[0].Type)
						{
							case 1:
								currentLayer = rail9VLayer;
								break;
							case 3:
							case 4:
								currentLayer = monorailLayer;
								break;
							default:
								currentLayer = baseplateLayer;
								break;
						}
					}
					else
					{
						currentLayer = baseplateLayer;
					}

					// check if we have to remap the connexion
					float diffAngleBtwTDandBB = 0;
					// try to get the conexion remap data
					if (portIdOfOrigin < remapData.mConnexionData.Count)
					{
						BrickLibrary.Brick.TDRemapData.ConnexionData connexion = remapData.mConnexionData[portIdOfOrigin];
						brick.ActiveConnectionPointIndex = connexion.mBBConnexionPointIndex;
						diffAngleBtwTDandBB = connexion.mDiffAngleBtwTDandBB;
					}

					// the brick with connections, use there connexion point as origin of their position
					if (brick.ConnectionPoints != null)
					{
						// set the angle of the brick first
						brick.Orientation = (float)angle + diffAngleBtwTDandBB;
						// then set the position
						brick.ActiveConnectionPosition = new PointF((float)x, (float)y);
					}
					else
					{
						// first rotate the brick to have it like in TD
						// such has the brick.Image.Width is correct
						if (diffAngleBtwTDandBB != 0)
							brick.Orientation = diffAngleBtwTDandBB;
						// if the brick don't have connexion point, the position of the TD brick be the middle
						// of the left border, but of course we need to rotate this virtual connexion point
						Matrix rotation = new Matrix();
						rotation.Rotate((float)angle);
						PointF[] originToCenter = { new PointF(brick.Width / 2, 0) };
						rotation.TransformVectors(originToCenter);
						x += originToCenter[0].X;
						y += originToCenter[0].Y;
						// set the correct angle of the brick
						brick.Orientation = (float)angle + diffAngleBtwTDandBB;
						// set the position from the center that we have computed
						brick.Center = new PointF((float)x, (float)y);
					}


					// add the brick to the layer
					currentLayer.addBrick(brick, -1);

					// special case for the monorail ramp in TD, it's only one part but in fact it is two part in LDRAW
					if ((TDPartNumber == 232677) || (TDPartNumber == 232678))
					{
						// create the second part of the ramp
						LayerBrick.Brick rampBrick = null;
						if (TDPartNumber == 232677)
						{
							rampBrick = new LayerBrick.Brick("2678.7");
							brick.ActiveConnectionPointIndex = 1;
							rampBrick.ActiveConnectionPointIndex = 0;
						}
						else
						{
							rampBrick = new LayerBrick.Brick("2677.7");
							brick.ActiveConnectionPointIndex = 0;
							rampBrick.ActiveConnectionPointIndex = 1;
						}
						// normally it should be: rampBrick.Orientation = (float)angle + diffAngleBtwTDandBB;
						rampBrick.Orientation = Actions.Bricks.AddConnectBrick.sGetOrientationOfConnectedBrick(brick, rampBrick);						
						rampBrick.ActiveConnectionPosition = brick.ActiveConnectionPosition;
						currentLayer.addBrick(rampBrick, -1);
					}
				}
				else
				{
					if (!noRemapablePartFound.Contains(TDPartNumber))
						noRemapablePartFound.Add(TDPartNumber);
				}

				// move the progressbar according to the number of byte read (each part takes 106 bytes)
				MainForm.Instance.stepProgressBar(106);
			}

			// close the stream
			binaryReader.Close();
			myFileStream.Close();

			// add the layers that are not empty
			if (baseplateLayer.BrickList.Count > 0)
			{
				baseplateLayer.Name = "Baseplate";
				baseplateLayer.updateFullBrickConnectivity();
				Map.Instance.addLayer(baseplateLayer);
			}
			if (rail9VLayer.BrickList.Count > 0)
			{
				rail9VLayer.Name = "Rail";
				rail9VLayer.updateFullBrickConnectivity();
				Map.Instance.addLayer(rail9VLayer);
			}
			if (monorailLayer.BrickList.Count > 0)
			{
				monorailLayer.Name = "Monorail";
				monorailLayer.updateFullBrickConnectivity();
				Map.Instance.addLayer(monorailLayer);
			}

			// finish the progressbar to hide it
			MainForm.Instance.finishProgressBar();

			// check if we found some part that can be remaped
			if (noRemapablePartFound.Count > 0)
			{
				string message = Properties.Resources.ErrorMsgMissingTDRemap;
				foreach (int id in noRemapablePartFound)
					message += id.ToString() + ", ";
				message = message.Remove(message.Length - 2) + ".";
				MessageBox.Show(null, message,
					Properties.Resources.ErrorMsgTitleWarning, MessageBoxButtons.OK,
					MessageBoxIcon.Information, MessageBoxDefaultButton.Button1);
			}

			// the file can be open
			return true;
		}

		private static int loadTDLHeader(BinaryReader binaryReader)
		{
			// read the origin point
			int originX = binaryReader.ReadInt32();
			int originY = binaryReader.ReadInt32();
			// read the number of pieces
			int nbPieces = binaryReader.ReadInt32();
			// read the number of the file version that must be 20
			int fileVersionNumber = binaryReader.ReadInt32();
			if (fileVersionNumber != 20)
			{
				MessageBox.Show(null, Properties.Resources.ErrorMsgOldTDFile,
					Properties.Resources.ErrorMsgTitleWarning, MessageBoxButtons.OK,
					MessageBoxIcon.Information, MessageBoxDefaultButton.Button1);
				return -1;
			}
			// read the boundaries of the map (in stud coord)
			int boundXMin = binaryReader.ReadInt32();
			int boundYMin = binaryReader.ReadInt32();
			int boundXMax = binaryReader.ReadInt32();
			int boundYMax = binaryReader.ReadInt32();
			// position and angle of the cursor
			double x = binaryReader.ReadDouble();
			double y = binaryReader.ReadDouble();
			double z = binaryReader.ReadDouble();
			double angle = binaryReader.ReadDouble();
			// number of the selected port (connection point) of the selected part
			int selectedPortNumber = binaryReader.ReadInt32();
			// id of the selected part
			int partId = binaryReader.ReadInt32();
			// read the size of boundaries of the map (in stud coord), normally it should be (boundXMax - boundXMin, boundYMax - boundYMin)
			int boundWidth = binaryReader.ReadInt32();
			int boundHeight = binaryReader.ReadInt32();
			// old dummy data (an empty CString)
			char dummyStringSize = binaryReader.ReadChar();
			// options flags and slopes??
			Map.Instance.AllowElectricShortCuts = (binaryReader.ReadInt32() != 0);
			int slope = binaryReader.ReadInt32();
			Map.Instance.AllowUnderground = (binaryReader.ReadInt32() != 0);
			Map.Instance.AllowSteps = (binaryReader.ReadInt32() != 0);
			Map.Instance.AllowSlopeMismatch = (binaryReader.ReadInt32() != 0);
			// description string
			char descriptionStringSize = binaryReader.ReadChar();
			Map.Instance.Event = new string(binaryReader.ReadChars(descriptionStringSize));
			// comment string
			char commentStringSize = binaryReader.ReadChar();
			Map.Instance.Comment = new string(binaryReader.ReadChars(commentStringSize));
			// now skip the piece list (normally it should be 0)
			int nbPiecesInPieceList = binaryReader.ReadInt16();
			int pieceListSize = 0;
			if (nbPiecesInPieceList > 0)
			{
				// ??? We don't support piece list, just skip them for now
				// read the header of the piece list (12 char) + all the pieces
				pieceListSize = 12 + (nbPiecesInPieceList * 40);
				binaryReader.ReadChars(pieceListSize);
			}
			// return the total of byte read
			return (105 + descriptionStringSize + commentStringSize + pieceListSize);
		}

		private static bool saveTDL(string filename)
		{
			// compute the number of brick to save
			int nbItems = 0;
			foreach (Layer layer in Map.Instance.LayerList)
			{
				// check the type because we only save brick layers
				LayerBrick brickLayer = layer as LayerBrick;
				if (brickLayer != null)
					nbItems += layer.NbItems;
			}
			// init the progress bar with the number of parts to write
			MainForm.Instance.resetProgressBar(nbItems + 2);

			// step the progressbar after the init of part remap
			MainForm.Instance.stepProgressBar();

			// update the registry to use
			BrickLibrary.Instance.updateCurrentTrackDesignerRegistryUsed();

			// open the file
			FileStream myFileStream = new FileStream(filename, FileMode.Create);
			BinaryWriter binaryWriter = new BinaryWriter(myFileStream);

			// write the header of the file
			saveTDLHeader(binaryWriter, nbItems);

			// step the progressbar after the write of the header
			MainForm.Instance.stepProgressBar();

			// now the piece list (record the stream position because the number of item may changed if some brick were skipped)
			long streamPositionOfNbItem = binaryWriter.BaseStream.Position;
			binaryWriter.Write((short)nbItems); // the number of piece in the TrackPiece list

			if (nbItems > 0)
			{
				int nbItemsWritten = 0;

				// write the header of the CTrackPieces list (containing the string "CTrackPiece")
				binaryWriter.Write((int)0x14FFFF);
				binaryWriter.Write((short)0x0B);
				binaryWriter.Write((char[])"CTrackPiece".ToCharArray());

				// save all the bricks
				foreach (Layer layer in Map.Instance.LayerList)
				{
					// check the type because we only save brick layers
					LayerBrick brickLayer = layer as LayerBrick;
					if (brickLayer != null)
						foreach (LayerBrick.Brick brick in brickLayer.BrickList)
						{
							// save the brick
							if (saveOneBrickInTDL(binaryWriter, brick, (nbItemsWritten > 0)))
								nbItemsWritten++;
							// step the progress bar
							MainForm.Instance.stepProgressBar();
						}
				}

				// check if some items were skip, then we have to rewrite the number of items
				if (nbItemsWritten < nbItems)
				{
					binaryWriter.BaseStream.Position = 8;
					binaryWriter.Write((short)nbItemsWritten);
					binaryWriter.BaseStream.Position = streamPositionOfNbItem;
					binaryWriter.Write((short)nbItemsWritten);
				}
			}

			// close the binary writer to close the file
			binaryWriter.Close();

			// finish the progressbar to hide it
			MainForm.Instance.finishProgressBar();

			return true;
		}

		private static int getConnectedBrickOtherBBConnexionIndex(LayerBrick.Brick brick, int connexionIndexOnBrick, LayerBrick.Brick connectedBrick)
		{
			int connectedBrickOtherBBConnexionIndex = 0;
			// check if the connected brick is not null which may happen
			if (connectedBrick != null)
			{
				// get the connected connexion
				LayerBrick.Brick.ConnectionPoint connectedConnexion = brick.ConnectionPoints[connexionIndexOnBrick].ConnectionLink;
				// search the BB connexion index of the connected brick
				foreach (LayerBrick.Brick.ConnectionPoint connexion in connectedBrick.ConnectionPoints)
					if (connexion != connectedConnexion)
						connectedBrickOtherBBConnexionIndex++;
					else
						break;
			}
			return connectedBrickOtherBBConnexionIndex;
		}

		private static bool saveOneBrickInTDL(BinaryWriter binaryWriter, LayerBrick.Brick brick, bool writeSeparatorWord)
		{
			// try to get the remap data structure
			BrickLibrary.Brick.TDRemapData remapData = BrickLibrary.Instance.getTDRemapData(brick.PartNumber);

			// check if we found the correct remap data
			if (remapData != null)
			{
				// special case for a down ramp (TD give to the up and down ramp the same id with different bitmap id)
				// this part doesn't exist in TD, so we skip it.
				if (remapData.mTDId.ID == 232678)
					return false;

				// write one word (2 bytes that I don't know the meaning maybe comming from the list)
				// except for the first brick (specified with the parameter)
				if (writeSeparatorWord)
					binaryWriter.Write((ushort)0x8001);

				// write the TD part number
				binaryWriter.Write((int)remapData.mTDId.ID);

				// write an instance ID (use the hash code for that)
				binaryWriter.Write((int)brick.GetHashCode());

				// by default we use the active connection point to find the corresponding
				// port id of origin. But some parts like the straight or the cross over, can
				// have different connection point in BB but only one port id in TD because it
				// is a symetric part. So for those parts we only use the first BB connection point
				int connectionPointIndex = brick.ActiveConnectionPointIndex;
				if (!remapData.mHasSeveralPort)
					connectionPointIndex = 0;

				// check if we have to remap the connexion
				int portIdOfOrigin = -1;
				int partType = 0;
				float diffAngleBtwTDandBB = 0;
				// search the connexion point 0
				foreach (BrickLibrary.Brick.TDRemapData.ConnexionData connexion in remapData.mConnexionData)
				{
					// increment the port id
					portIdOfOrigin++;
					// check if we found the port for which the BB connexion id is equal to the current active connexion
					if (connexion.mBBConnexionPointIndex == connectionPointIndex)
					{
						partType = connexion.mType;
						diffAngleBtwTDandBB = connexion.mDiffAngleBtwTDandBB;
						break;
					}
				}

				// the brick with connections, use there connexion point as origin of their position
				double orientation = 0.0;
				PointF position;
				if ((brick.ConnectionPoints != null) && (connectionPointIndex < brick.ConnectionPoints.Count))
				{
					// set the angle of the brick first
					orientation = (double)(brick.Orientation - diffAngleBtwTDandBB);
					// then set the position by getting it from the corresponding connection point
					position = brick.ConnectionPoints[connectionPointIndex].PositionInStudWorldCoord;
				}
				else
				{
					// set the correct angle of the brick
					orientation = (double)(brick.Orientation - diffAngleBtwTDandBB);
					// set the position from the center that we have computed
					position = brick.Center;
					// first rotate the brick to have it like in TD
					// such has the brick.Image.Width is correct
					LayerBrick.Brick dummyBrickToGetWidth = new LayerBrick.Brick(brick.PartNumber);
					if (diffAngleBtwTDandBB != 0)
						dummyBrickToGetWidth.Orientation = diffAngleBtwTDandBB;
					// if the brick don't have connexion point, the position of the TD brick be the middle
					// of the left border, but of course we need to rotate this virtual connexion point
					Matrix rotation = new Matrix();
					rotation.Rotate((float)orientation);
					PointF[] originToCenter = { new PointF(dummyBrickToGetWidth.Width / 2, 0) };
					rotation.TransformVectors(originToCenter);
					position.X -= originToCenter[0].X;
					position.Y -= originToCenter[0].Y;
				}

				// normalize the rotation between 0 and 360
				while (orientation < 0.0f)
					orientation += 360.0f;
				while (orientation >= 360.0f)
					orientation -= 360.0f;
				// write the angle in degree
				binaryWriter.Write((double)orientation);

				// write the position in stud
				binaryWriter.Write((double)position.X);
				binaryWriter.Write((double)position.Y);
				binaryWriter.Write((double)brick.Altitude);

				// the type of the part (an int) (0 = Straight, 1 = Left Curve, 2 = Right Curve, 3 = Left Split, 4 = Right Split, 5 = Left Merge, 6 = Right Merge, 7 = Left Join, 8 = Right Join, 9 = Crossover, 10 = T Junction, 11 = Up Ramp, 12 = Down Ramp, 13 = Short Straight, 14 = Short Left Curve In, 15 = Short Right Curve In, 16 = Short Left Curve Out, 17 = Short Right Curve Out, 18 = Left Reverse Switch, 19 = Right Reverse Switch, 20 = Custom)
				binaryWriter.Write((int)partType);

				// the id of bitmap (an int) when a part (like a curve) has two bitmap in the TrackDesigner part library, or for two baseplase with different color
				// but in TD code, this is since as the port id (i.e. connexion id) that is used as the origin point of the part
				binaryWriter.Write((int)portIdOfOrigin);

				// 4 structures for the 4 possibles connexions
				for (int i = 0; i < 4; ++i)
				{
					int connectedBrickInstanceId = 0;
					int connectedBrickOtherPortId = 0;
					int connectedBrickPolarity = 0;

					// check if the brick has some connection point
					if ((brick.ConnectionPoints != null) && (i < remapData.mConnexionData.Count))
					{
						// get the corresponding connexion index of the BB part for the ith TD port id
						int BBConnexionIndexForI = remapData.mConnexionData[i].mBBConnexionPointIndex;
						// check if the connexion index is valid
						if (BBConnexionIndexForI < brick.ConnectionPoints.Count)
						{
							// get the polarity of the connection
							if (brick.ConnectionPoints[BBConnexionIndexForI].Polarity < 0)
								connectedBrickPolarity = 2; // in TD 2 == -ve
							else if (brick.ConnectionPoints[BBConnexionIndexForI].Polarity > 0)
								connectedBrickPolarity = 3; // in TD 3 == +ve

							// get the connected brick at the BB connexion point
							LayerBrick.Brick connectedBrick = brick.ConnectionPoints[BBConnexionIndexForI].ConnectedBrick;
							// search the BB connexion index of the connected brick
							int connectedBrickOtherBBConnexionIndex = getConnectedBrickOtherBBConnexionIndex(brick, BBConnexionIndexForI, connectedBrick);
							while (connectedBrick != null)
							{
								// special case for the down ramp that doesn't exist in TD, in fact the down ramp is merged
								// inside the up ramp. So we need to skip the down ramp and continue with the next linked part
								if (connectedBrick.PartNumber.StartsWith("2678."))
								{
									// take the other connexion point of the 2678 part (that only have 2 connexion points)
									int nextConnexionIndex = 0;
									if (connectedBrickOtherBBConnexionIndex == 0)
										nextConnexionIndex = 1;
									else
										nextConnexionIndex = 0;
									// get the next connected brick (which can be null)
									LayerBrick.Brick nextConnectedBrick = connectedBrick.ConnectionPoints[nextConnexionIndex].ConnectedBrick;
									connectedBrickOtherBBConnexionIndex = getConnectedBrickOtherBBConnexionIndex(connectedBrick, nextConnexionIndex, nextConnectedBrick);
									// continue to the next brick
									connectedBrick = nextConnectedBrick;
									continue;
								}

								// compute the instance id
								connectedBrickInstanceId = connectedBrick.GetHashCode();

								// so now connectedBrickOtherBBConnexionIndex contain the BB connexion index, and we
								// have to remap this index to the TD port id so get the remap data of the connect brick
								BrickLibrary.Brick.TDRemapData connectedRemapData = BrickLibrary.Instance.getTDRemapData(connectedBrick.PartNumber);
								// if we found the remap data of the connected brick
								if (connectedRemapData != null)
								{
									// try to find the same BB connexion index, and the TD port id is the index j in the array
									for (int j = 0; j < connectedRemapData.mConnexionData.Count; ++j)
										if (connectedBrickOtherBBConnexionIndex == connectedRemapData.mConnexionData[j].mBBConnexionPointIndex)
										{
											connectedBrickOtherPortId = j;
											break;
										}
								}

								// stop the loop
								break;
							}
						}
					}

					// write the instance ID of the first connected brick
					binaryWriter.Write((int)connectedBrickInstanceId);
					// write the Port number connected to on other piece
					binaryWriter.Write((int)connectedBrickOtherPortId);
					// write the Port polarity: 0 unasasigned, 2 -ve, 3 +ve
					binaryWriter.Write((int)connectedBrickPolarity);
				}

				// write the flags
				// TPF_ATTACHMENT     1     // piece is an attachment      
				// TPF_SUPPORT        2     // piece is used to support elevation
				// TPF_MODIFIED       4     // piece has been modified
				// TPF_CONNECTION_MADE 8    // piece has been modified
				binaryWriter.Write((int)remapData.mFlags);

				// write the slope
				binaryWriter.Write((int)0);

				// the part was correctly written
				return true;
			}

			// the remap was not found, the part was not written
			return false;
		}

		private static void saveTDLHeader(BinaryWriter binaryWriter, int nbTotalBricks)
		{
			// get the boundaries of the map
			RectangleF boundaries = Map.Instance.getTotalAreaInStud(true);
			const int margin = 5;
			boundaries.X = (int)Math.Round(boundaries.X) - margin;
			boundaries.Width = (int)Math.Round(boundaries.Width) + (margin * 2);
			boundaries.Y = (int)Math.Round(boundaries.Y) - margin;
			boundaries.Height = (int)Math.Round(boundaries.Height) + (margin * 2);

			// write the origin point (x,y)
			binaryWriter.Write((int)-boundaries.Left);
			binaryWriter.Write((int)-boundaries.Top);

			// write the number of pieces
			binaryWriter.Write((int)nbTotalBricks);

			// write the number of the file version that must be 20
			binaryWriter.Write((int)20);

			// save the boundaries
			binaryWriter.Write((int)boundaries.Left); // x min
			binaryWriter.Write((int)boundaries.Top); // y min
			binaryWriter.Write((int)boundaries.Right); // x max
			binaryWriter.Write((int)boundaries.Bottom); // y max

			// get the current selected brick if any
			LayerBrick.Brick selectedBrick = null;
			if (Map.Instance.SelectedLayer != null)
			{
				LayerBrick brickLayer = Map.Instance.SelectedLayer as LayerBrick;
				if ((brickLayer != null) && (brickLayer.SelectedObjects.Count > 0))
					selectedBrick = brickLayer.SelectedObjects[0] as LayerBrick.Brick;
			}

			// get different data to save depending if we have a selected brick or not
			PointF cursorPosition;
			double cursorPositionAltitude = 0.0;
			double cursorAngle = 0.0;
			int selectedPort = 0;
			int selectedBrickId = 0;
			if (selectedBrick != null)
			{
				cursorPositionAltitude = (double)selectedBrick.Altitude;
				selectedBrickId = selectedBrick.GetHashCode();
				if (selectedBrick.HasConnectionPoint)
				{
					// get the cursor position from the selected connection of the selected part
					cursorPosition = selectedBrick.ActiveConnectionPosition;
					cursorAngle = (double)selectedBrick.ActiveConnectionAngle;
					selectedPort = selectedBrick.ActiveConnectionPointIndex;
				}
				else
				{
					// get the cursor position from the selected brick
					cursorPosition = selectedBrick.Center;
				}
			}
			else
			{
				// get the cursor position from the left top most position (this function return (0,0) if there's no bricks)
				cursorPosition = Map.Instance.getMostTopLeftBrickPosition();
			}

			// save the cursor position
			binaryWriter.Write((double)cursorPosition.X);
			binaryWriter.Write((double)cursorPosition.Y);
			binaryWriter.Write((double)cursorPositionAltitude);
			// save the angle of the cursor
			binaryWriter.Write((double)cursorAngle);
			// selected port of the selected part
			binaryWriter.Write((int)selectedPort);
			// selected part hashcode (as an id)
			binaryWriter.Write((int)selectedBrickId);

			// size of the document
			binaryWriter.Write((int)boundaries.Width);
			binaryWriter.Write((int)boundaries.Height);
			// old dummy data (an empty CString)
			binaryWriter.Write((char)0);

			// options flags and slopes??
			binaryWriter.Write((int)(Map.Instance.AllowElectricShortCuts ? 1 : 0));
			binaryWriter.Write((int)0); // slopes, what is it ???
			binaryWriter.Write((int)(Map.Instance.AllowUnderground ? 1 : 0));
			binaryWriter.Write((int)(Map.Instance.AllowSteps ? 1 : 0));
			binaryWriter.Write((int)(Map.Instance.AllowSlopeMismatch ? 1 : 0));

			// description string (the TDL file only support a maximum number of 255 char
			// because the first char is the length of the string)
			string description = Map.Instance.Event.Clone() as string;
			if (description.Length > 255)
				description = description.Substring(0, 255);
			binaryWriter.Write((char)description.Length);
			binaryWriter.Write((char[])description.ToCharArray());
			// comment string (the TDL file only support a maximum number of 255 char
			// because the first char is the length of the string)
			string comment = Map.Instance.Comment.Clone() as string;
			if (comment.Length > 255)
				comment = description.Substring(0, 255);
			binaryWriter.Write((char)comment.Length);
			binaryWriter.Write((char[])comment.ToCharArray());

			// now the piece list (normally it's an empty list)
			binaryWriter.Write((short)0); // the number of piece in the piece list
		}

		#endregion
		#region 4DBrix nControl
		/// <summary>
		/// This struct is for optimization reason, in order to ask the remap data only once to the brick library
		/// </summary>
		private struct FourDBrixPart
		{
			public BrickLibrary.Brick.FourDBrixRemapData mRemapData;
			public LayerBrick.Brick mBrick;
		}

		/// <summary>
		/// This struct is used to store temporary the coordinates of a node that is read in the ncp file
		/// </summary>
		private struct FourDBrixNodeCoord
		{
			public float mX;
			public float mY;
			public float mZ;
		}

		/// <summary>
		/// This struct is used to store temporary the segments (or bricks) because we can only construct the segment once the file
		/// is finished to be read, as maybe a node could be declared after a segment, and segments need nodes to know their positions
		/// </summary>
		private class FourDBrixSegment
		{
			public string mPartId; // the 4DBrix part number/id, that will be used to ask the Brick library the corresponding BlueBrick part number
			public int mOriginNodeIndex; // The index in the list of all the nodes declared in the file, on which this part is attached. We will use this node coordinate to place the part
			public float mAngle; // the angle of the part
			public int mGUID; // the id of the segment instance, use to create the groups
			public LayerBrick.Brick mBrick; // the BlueBrick brick hat was created for this segment (in order to recreate the group)
		}

		/// <summary>
		/// This struct is used to temporary store the group read in the ncp file (a group is a list of segment GUID)
		/// </summary>
		private struct FourDBrixGroup
		{
			public List<int> mGUIDInTheGroup;
		}

		private static bool load4DBrix(string filename)
		{
			// create a new map and different layer for different type of parts
			Map.Instance = new Map();
			LayerBrick tableLayer = new LayerBrick();
			tableLayer.Name = "Tables";
			LayerBrick baseplateLayer = new LayerBrick();
			baseplateLayer.Name = "Baseplates";
			LayerBrick trackLayer = new LayerBrick();
			trackLayer.Name = "Tracks";
			LayerBrick structureLayer = new LayerBrick();
			structureLayer.Name = "Structures";
			// a list to store all the corrdinates of the node found (because in ncp format, the connection points are separated from the bricks)
			List<FourDBrixNodeCoord> nodeCoordinates = new List<FourDBrixNodeCoord>();
			// a list to also store the segment, we then instantiate the bricks by combining the two list after the file as been fully parsed
			List<FourDBrixSegment> segments = new List<FourDBrixSegment>();
			// a list to store all the groups that we will read in the file
			List<FourDBrixGroup> groups = new List<FourDBrixGroup>();

			// declare a bool to check if we found some part not remaped in the library
			List<string> noRemapablePartFound = new List<string>();

			// create an XML reader to parse the data
			System.Xml.XmlReaderSettings xmlSettings = new System.Xml.XmlReaderSettings();
			xmlSettings.ConformanceLevel = System.Xml.ConformanceLevel.Document;
			xmlSettings.IgnoreWhitespace = true;
			xmlSettings.IgnoreComments = true;
			xmlSettings.CheckCharacters = false;
			xmlSettings.CloseInput = true;
			System.Xml.XmlReader xmlReader = System.Xml.XmlReader.Create(filename, xmlSettings);

			// first find and enter the unique root tag
			bool rootNodeFound = false;
			do
			{
				xmlReader.Read();
				rootNodeFound = xmlReader.Name.Equals("data");
			} while (!rootNodeFound && !xmlReader.EOF);

			// if we found the root node, start to parse it
			if (rootNodeFound)
			{
				// read the first child node
				xmlReader.Read();
				bool continueToRead = !xmlReader.EOF;
				while (continueToRead)
				{
					if (xmlReader.Name.Equals("project"))
						readProjectTagIn4DBrix(ref xmlReader);
					else if (xmlReader.Name.Equals("script"))
						readScriptTagIn4DBrix(ref xmlReader);
					else if (xmlReader.Name.Equals("node"))
						readNodeTagIn4DBrix(ref xmlReader, ref nodeCoordinates);
					else if (xmlReader.Name.Equals("segment"))
						readSegmentTagIn4DBrix(ref xmlReader, ref segments);
					else if (xmlReader.Name.Equals("table"))
						readGenericPartIn4DBrix(ref xmlReader, xmlReader.Name, tableLayer, false, ref noRemapablePartFound);
					else if (xmlReader.Name.Equals("baseplate"))
						readGenericPartIn4DBrix(ref xmlReader, xmlReader.Name, baseplateLayer, false, ref noRemapablePartFound);
					else if (xmlReader.Name.Equals("structure"))
						readGenericPartIn4DBrix(ref xmlReader, xmlReader.Name, structureLayer, true, ref noRemapablePartFound);
					else if (xmlReader.Name.Equals("group"))
						readGroupIn4DBrix(ref xmlReader, groups);
					else
						xmlReader.Read();
					// check if we need to continue
					continueToRead = !xmlReader.Name.Equals("data") && !xmlReader.EOF;
				}
			}

			// close the xml file
			xmlReader.Close();

			// after we have finished to read the file, we can fill the track layer with the bluebrick parts, from the nodes and segment that we found in the file
			createBricksFromNodeAndSegment(trackLayer, nodeCoordinates, segments, ref noRemapablePartFound);

			// and then create the groups
			createGroupsFromSegmentAndGroupIdList(segments, groups);

			// add the layers to the map in the correct order
			Map.Instance.addLayer(new LayerGrid());
			Map.Instance.addLayer(tableLayer);
			Map.Instance.addLayer(baseplateLayer);
			Map.Instance.addLayer(trackLayer);
			Map.Instance.addLayer(structureLayer);

			// select the track layer by default
			Map.Instance.SelectedLayer = trackLayer;

			// finish the progress bar (to hide it)
			MainForm.Instance.finishProgressBar();

			// check if we found some part that can be remaped
			if (noRemapablePartFound.Count > 0)
			{
				// check if the 4DBrix library is installed, if not, display a warning message to encourage the user to download the library
				if (!Directory.Exists(Application.StartupPath + @"/parts/4DBrix"))
					MessageBox.Show(null, Properties.Resources.ErrorMsgMissing4DBrixLibrary,
						Properties.Resources.ErrorMsgTitleWarning, MessageBoxButtons.OK,
						MessageBoxIcon.Information, MessageBoxDefaultButton.Button1);

				// show the message for the unknown bricks
				string message = Properties.Resources.ErrorMsgMissing4DBrixRemap;
				foreach (string id in noRemapablePartFound)
					message += id + ", ";
				message = message.Remove(message.Length - 2) + ".";
				MessageBox.Show(null, message,
					Properties.Resources.ErrorMsgTitleWarning, MessageBoxButtons.OK,
					MessageBoxIcon.Information, MessageBoxDefaultButton.Button1);
			}

			// the file can be open
			return true;
		}

		private static void readProjectTagIn4DBrix(ref System.Xml.XmlReader xmlReader)
		{
			// check if the description is not empty
			bool continueToRead = !xmlReader.IsEmptyElement;
			if (continueToRead)
			{
				// read the first child node (and check that it is not the end element)
				xmlReader.Read();
				continueToRead = !xmlReader.Name.Equals("project") && !xmlReader.EOF;
				while (continueToRead)
				{
					if (xmlReader.Name.Equals("title"))
						Map.Instance.Event = unescapeSpecialXMLCharacter(xmlReader.GetAttribute("value"));
					else if (xmlReader.Name.Equals("author"))
						Map.Instance.Author = unescapeSpecialXMLCharacter(xmlReader.GetAttribute("value"));
					else if (xmlReader.Name.Equals("lug"))
						Map.Instance.LUG = unescapeSpecialXMLCharacter(xmlReader.GetAttribute("value"));
					else if (xmlReader.Name.Equals("info"))
						Map.Instance.Comment = unescapeSpecialXMLCharacter(xmlReader.GetAttribute("value"));
					// read the tag anyway after having read the property
					xmlReader.Read();
					// check if we reach the end of the Description
					continueToRead = !xmlReader.Name.Equals("project") && !xmlReader.EOF;
				}
				// finish the Description tag
				if (!xmlReader.EOF)
					xmlReader.ReadEndElement();
			}
			else
			{
				xmlReader.Read();
			}
		}

		private static void readScriptTagIn4DBrix(ref System.Xml.XmlReader xmlReader)
		{
			// check if the description is not empty
			bool continueToRead = !xmlReader.IsEmptyElement;
			if (continueToRead)
			{
				// read the first child node (and check that it is not the end element)
				xmlReader.Read();
				continueToRead = !xmlReader.Name.Equals("script") && !xmlReader.EOF;
				while (continueToRead)
				{
					// completely skip the script tags, BlueBrick cannot do anything with that
					// read the tag anyway after having read the property
					xmlReader.Read();
					// check if we reach the end of the Description
					continueToRead = !xmlReader.Name.Equals("script") && !xmlReader.EOF;
				}
				// finish the Description tag
				if (!xmlReader.EOF)
					xmlReader.ReadEndElement();
			}
			else
			{
				xmlReader.Read();
			}
		}

		private static void readNodeTagIn4DBrix(ref System.Xml.XmlReader xmlReader, ref List<FourDBrixNodeCoord> nodeCoordinates)
		{
			// check if the description is not empty
			bool continueToRead = !xmlReader.IsEmptyElement;
			if (continueToRead)
			{
				// declare a coord struct
				FourDBrixNodeCoord coord = new FourDBrixNodeCoord() { mX = 0, mY = 0, mZ = 0 };

				// read the first child node (and check that it is not the end element)
				xmlReader.Read();
				continueToRead = !xmlReader.Name.Equals("node") && !xmlReader.EOF;
				while (continueToRead)
				{
					// we only care about the node coordinates, the rest is useless for BlueBrick
					if (xmlReader.Name.Equals("coordinates"))
					{
						// parse the values of the coordinates
						float.TryParse(xmlReader.GetAttribute("x"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out coord.mX);
						float.TryParse(xmlReader.GetAttribute("y"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out coord.mY);
						float.TryParse(xmlReader.GetAttribute("z"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out coord.mZ);
					}
					// read the tag anyway after having read the property
					xmlReader.Read();
					// check if we reach the end of the Description
					continueToRead = !xmlReader.Name.Equals("node") && !xmlReader.EOF;
				}
				// finish the Description tag
				if (!xmlReader.EOF)
					xmlReader.ReadEndElement();

				// add the coord in the list
				nodeCoordinates.Add(coord);
			}
			else
			{
				xmlReader.Read();
			}
		}

		private static void readSegmentTagIn4DBrix(ref System.Xml.XmlReader xmlReader, ref List<FourDBrixSegment> segments)
		{
			// check if the description is not empty
			bool continueToRead = !xmlReader.IsEmptyElement;
			if (continueToRead)
			{
				// declare the segment in which we will store the data we need to read
				FourDBrixSegment currentSegment = new FourDBrixSegment() { mPartId = string.Empty, mOriginNodeIndex = 0, mAngle = 0};
				List<int> globalNodesIndexOfTheSegment = new List<int>();

				// read the first child node (and check that it is not the end element)
				xmlReader.Read();
				continueToRead = !xmlReader.Name.Equals("segment") && !xmlReader.EOF;
				while (continueToRead)
				{
					if (xmlReader.Name.Equals("index"))
						int.TryParse(xmlReader.GetAttribute("value"), out currentSegment.mGUID);
					else if (xmlReader.Name.Equals("type"))
						currentSegment.mPartId = xmlReader.GetAttribute("value");
					else if (xmlReader.Name.Equals("angle"))
						float.TryParse(xmlReader.GetAttribute("value"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out currentSegment.mAngle);
					else if (xmlReader.Name.Equals("origin"))
						int.TryParse(xmlReader.GetAttribute("value"), out currentSegment.mOriginNodeIndex); // for now store the local origin node index
					else if (xmlReader.Name.StartsWith("node") && !xmlReader.Name.Equals("nodes"))
					{
						// we also need to read the global node index that this segment use, to store it in the origin after the read is complete
						int nodeIndex = 0;
						if (int.TryParse(xmlReader.GetAttribute("value"), out nodeIndex))
							globalNodesIndexOfTheSegment.Add(nodeIndex);
					}
					// read the tag anyway after having read the property
					xmlReader.Read();
					// check if we reach the end of the Description
					continueToRead = !xmlReader.Name.Equals("segment") && !xmlReader.EOF;
				}
				// finish the Description tag
				if (!xmlReader.EOF)
					xmlReader.ReadEndElement();

				// add the segment in the list if at least we have a valid part name
				if (currentSegment.mPartId != string.Empty)
				{
					// remap the local origin node index into the global node index
					if (currentSegment.mOriginNodeIndex < globalNodesIndexOfTheSegment.Count)
						currentSegment.mOriginNodeIndex = globalNodesIndexOfTheSegment[currentSegment.mOriginNodeIndex];
					// then add the segment in the list
					segments.Add(currentSegment);
				}
			}
			else
			{
				xmlReader.Read();
			}
		}

		private static void createBricksFromNodeAndSegment(LayerBrick layer, List<FourDBrixNodeCoord> nodeCoordinates, List<FourDBrixSegment> segments, ref List<string> noRemapablePartFound)
		{
			// iterate on all the segments (which are the equivalent to the bricks)
			foreach (FourDBrixSegment segment in segments)
			{
				// first try to find the equivalent brick in the brick library
				BrickLibrary.Brick libBrick = BrickLibrary.Instance.getBrickFrom4DBrixPartName(segment.mPartId);
				// if we found a brick in the brick library matching the 4DBrix part name, we can add the brick to the current layer
				if (libBrick != null)
				{
					// create a new brick
					LayerBrick.Brick brick = new LayerBrick.Brick(libBrick.mPartNumber);

					// also save the BlueBrick brick created for this segement, because we will need it for recreating the groups
					segment.mBrick = brick;

					// rotate the brick (will recompute the correct OffsetFromOriginalImage)
					brick.Orientation = segment.mAngle - libBrick.m4DBrixRemapData.mOrientationDifference;

					// check if the origin node for this segement is valid
					if (segment.mOriginNodeIndex < nodeCoordinates.Count)
					{
						// get the coordinate of the origin node for this brick
						FourDBrixNodeCoord nodeCoord = nodeCoordinates[segment.mOriginNodeIndex];

						// check in the remap data to which BlueBrick connection point, correspond the origin of a 4DBrix segment
						brick.ActiveConnectionPointIndex = libBrick.m4DBrixRemapData.mConnectionIndexUsedAsOrigin;

						// rescale the position because in 4DBrix, position are in millimeters and set position of the brick through the active connection point
						brick.ActiveConnectionPosition = new PointF(nodeCoord.mX * 0.125f, nodeCoord.mY * 0.125f); // or divided by 8

						// set also the altitude
						brick.Altitude = nodeCoord.mZ * 2.5f; // or divided by 0.4f;
					}

					// add the brick to the layer
					layer.addBrick(brick, -1);
				}
				else
				{
					// no brick created for this segment
					segment.mBrick = null;

					// else add this unknown part in the error list (if not already in)
					if (!noRemapablePartFound.Contains(segment.mPartId))
						noRemapablePartFound.Add(segment.mPartId);
				}
			}

			// then update the connectivy and sort the bricks by elevation
			layer.updateFullBrickConnectivity();
			layer.sortBricksByElevation();
		}

		private static void readGenericPartIn4DBrix(ref System.Xml.XmlReader xmlReader, string partTag, LayerBrick layer, bool isCoordInCenter, ref List<string> noRemapablePartFound)
		{
			// check if the description is not empty
			bool continueToRead = !xmlReader.IsEmptyElement;
			if (continueToRead)
			{
				// we need to memorize each parameter read, because usually the part id is at the end
				float x = 0;
				float y = 0;
				float angle = 0;
				string partNumber = string.Empty;

				// get the tag used for saving the coordinates
				string coordTag = isCoordInCenter ? "center" : "coordinates";

				// read the first child node (and check that it is not the end element)
				xmlReader.Read();
				continueToRead = !xmlReader.Name.Equals(partTag) && !xmlReader.EOF;
				while (continueToRead)
				{
					if (xmlReader.Name.Equals(coordTag))
					{
						float.TryParse(xmlReader.GetAttribute("x"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out x);
						float.TryParse(xmlReader.GetAttribute("y"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out y);
					}
					else if (xmlReader.Name.Equals("angle"))
					{
						float.TryParse(xmlReader.GetAttribute("value"), System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out angle);
					}
					else if (xmlReader.Name.Equals("svgfile"))
					{
						partNumber = xmlReader.GetAttribute("value");
					}
					// we don't care about the "size" tag, as BlueBrick already know the size of the parts from its database
					// read the tag anyway after having read the property
					xmlReader.Read();
					// check if we reach the end of the Description
					continueToRead = !xmlReader.Name.Equals(partTag) && !xmlReader.EOF;
				}
				// finish the Description tag
				if (!xmlReader.EOF)
					xmlReader.ReadEndElement();

				// After reading all the tags, check if we have read a valid 4DBrix part number
				if (partNumber != string.Empty)
				{
					// check if we can find the equivalent brick in the library
					BrickLibrary.Brick libBrick = BrickLibrary.Instance.getBrickFrom4DBrixPartName(partNumber);
					// if we found a brick in the brick library matching the 4DBrix part name, we can add the brick to the current layer
					if (libBrick != null)
					{
						// create a new brick
						LayerBrick.Brick brick = new LayerBrick.Brick(libBrick.mPartNumber);

						// rotate the brick (will recompute the correct OffsetFromOriginalImage)
						brick.Orientation = angle;

						// if the coordinates should be interpreted as center coordinate, shift them, as w
						if (isCoordInCenter)
						{
							// rescale the position because in 4DBrix, position are in millimeters (divide by 8), and give the adjustment due to the orientation
							x = (x * 0.125f) - brick.OffsetFromOriginalImage.X;
							y = (y * 0.125f) - brick.OffsetFromOriginalImage.Y;
							// and assign the center
							brick.Center = new PointF(x, y);
						}
						else
						{
							// rescale the position because in 4DBrix, position are in millimeters
							brick.TopLeftCornerPositionInStud = new PointF(x * 0.125f, y * 0.125f); // or divided by 8
						}

						// AFTER setting the correct position from the center of the top left corner, set again the orientation, this time with the orientation difference
						if (libBrick.m4DBrixRemapData.mOrientationDifference != 0f)
							brick.Orientation = angle - libBrick.m4DBrixRemapData.mOrientationDifference;

						// add the brick to the layer
						layer.addBrick(brick, -1);
					}
					else
					{
						// else add this unknown part in the error list
						noRemapablePartFound.Add(partNumber);
					}
				}
			}
			else
			{
				xmlReader.Read();
			}
		}

		private static void readGroupIn4DBrix(ref System.Xml.XmlReader xmlReader, List<FourDBrixGroup> groups)
		{
			// check if the description is not empty
			bool continueToRead = !xmlReader.IsEmptyElement;
			if (continueToRead)
			{
				// declare the segment in which we will store the data we need to read
				FourDBrixGroup currentGroup = new FourDBrixGroup() { mGUIDInTheGroup = new List<int>() };

				// read the first child node (and check that it is not the end element)
				xmlReader.Read();
				continueToRead = !xmlReader.Name.Equals("group") && !xmlReader.EOF;
				while (continueToRead)
				{
					if (xmlReader.Name.Equals("segments"))
					{
						string[] segmentList = xmlReader.GetAttribute("list").Split(new char[] { ',' });
						// once the string list is split try to parse all the numbers
						int guid = 0;
						foreach (string segmentGUID in segmentList)
							if (int.TryParse(segmentGUID, out guid))
								currentGroup.mGUIDInTheGroup.Add(guid);
					}
					// read the tag anyway after having read the property, and ignore the bounding box
					xmlReader.Read();
					// check if we reach the end of the Description
					continueToRead = !xmlReader.Name.Equals("group") && !xmlReader.EOF;
				}

				// if the group is not empty, add it to the list
				if (currentGroup.mGUIDInTheGroup.Count > 0)
					groups.Add(currentGroup);

				// finish the Description tag
				if (!xmlReader.EOF)
					xmlReader.ReadEndElement();
			}
			else
			{
				xmlReader.Read();
			}
		}
		private static void createGroupsFromSegmentAndGroupIdList(List<FourDBrixSegment> segments, List<FourDBrixGroup> groups)
		{
			foreach (FourDBrixGroup group in groups)
			{
				// create an empty BlueBrick Group
				Layer.Group bbGroup = new Layer.Group(true);

				// iterate on the guid id of the group and find it in the segment list
				foreach (int guid in group.mGUIDInTheGroup)
					foreach (FourDBrixSegment segment in segments)
						if ((segment.mGUID == guid) && (segment.mBrick != null))
						{
							bbGroup.addItem(segment.mBrick);
							// remove also the segment we found, to speed up the next search iteration
							// because a segment can only appear in one group
							segments.Remove(segment);
							// and stop the iteration for searching the segment
							break;
						}
			}
		}

		private static string unescapeSpecialXMLCharacter(string text)
		{
			// replace amp at last as we will add more in the string
			return text.Replace("&quot;", "\"").Replace("&apos;", "'").Replace("&lt;", "<").Replace("&gt;", ">").Replace("&amp;", "&");
		}

		private static string escapeSpecialXMLCharacter(string text)
		{
			// replace amp first as we will add more in the string
			return text.Replace("&", "&amp;").Replace("\"", "&quot;").Replace("'", "&apos;").Replace("<", "&lt;").Replace(">", "&gt;");
		}

		private static void saveHeaderIn4DBrix(StreamWriter textWriter, string filename)
		{
			// get the total area of the map (as we will need to save it
			RectangleF totalArea = Map.Instance.getTotalAreaInStud(true);

			// get the File Info of the current file if it already exists (for the creation date)
			string dateTimeFormat = "d-MMM-yyyy, HH:mm:ss";
			string now = DateTime.Now.ToString(dateTimeFormat, System.Globalization.CultureInfo.InvariantCulture);
			string creationTime = now;
			if (File.Exists(filename))
				creationTime = new FileInfo(filename).CreationTime.ToString(dateTimeFormat, System.Globalization.CultureInfo.InvariantCulture);

			// write the project general info
			textWriter.WriteLine("<?xml version=\"1.0\"?>");
			textWriter.WriteLine("<data type=\"nControl\" version=\"1\">");
			textWriter.WriteLine("   <project>");
			textWriter.WriteLine("      <ncontrol version=\"2020.0\"/>");
			textWriter.WriteLine("      <title value=\"" + escapeSpecialXMLCharacter(Map.Instance.Event) + "\"/>");
			textWriter.WriteLine("      <author value=\"" + escapeSpecialXMLCharacter(Map.Instance.Author) + "\"/>");
			textWriter.WriteLine("      <lug value=\"" + escapeSpecialXMLCharacter(Map.Instance.LUG) + "\"/>");
			textWriter.WriteLine("      <created value=\"" + creationTime + "\"/>");
			textWriter.WriteLine("      <modified value=\"" + now +"\"/>");
			textWriter.WriteLine("      <description value=\"" + Map.Instance.Date.ToString(dateTimeFormat, System.Globalization.CultureInfo.InvariantCulture) + "\"/>");
			textWriter.WriteLine("      <info value=\"" + escapeSpecialXMLCharacter(Map.Instance.Comment) + "\"/>");
			// for the tracklayout size, nControl only accept interger value in studs, and always assume the top left corner is (0,0)
			textWriter.WriteLine("      <tracklayout width=\"" + ((int)(totalArea.Right)).ToString() + "\" height=\"" + ((int)(totalArea.Bottom)).ToString() + "\" scale=\"0.25\"/>");
			textWriter.WriteLine("      <tilepanel rows=\"1\" columns=\"6\"/>");
			textWriter.WriteLine("   </project>");

			// write the script tags
			textWriter.WriteLine("   <script type=\"ST_ACTIVATION\">");
			textWriter.WriteLine("      <action value=\"\"/>");
			textWriter.WriteLine("   </script>");
			textWriter.WriteLine("   <script type=\"ST_DEACTIVATION\">");
			textWriter.WriteLine("      <action value=\"\"/>");
			textWriter.WriteLine("   </script>");
		}

		private static void saveOneNodeIn4DBrix(StreamWriter textWriter, LayerBrick.Brick.ConnectionPoint connectionPoint)
		{
			// get the two id of the bricks which are connected to this connection point.
			// if there's no brick, then "None" is used. All the connection point have a valid owner brick, because bluebrick don't allow loose connection point
			// unlike 4DBrix in which you can create floating nodes, which means the A segment will always be valid
			string ConnectedBrickAId = connectionPoint.OwnerBrick.GUID.ToString();
			string ConnectedBrickBId = "None";
			LayerBrick.Brick connectedBrick = connectionPoint.ConnectedBrick;
			if (connectedBrick != null)
				ConnectedBrickBId = connectedBrick.GUID.ToString();

			// compute the node coordinate
			// 4DBrix use milimeter for the unit of the coorrdinate system. Since one stud = 8 mm, we need to multiply by 8 the coord in studs.
			// And the conversion for the z coordinates, is from LDU to milimeters.
			float x = connectionPoint.PositionInStudWorldCoord.X * 8;
			float y = connectionPoint.PositionInStudWorldCoord.Y * 8;
			float z = connectionPoint.OwnerBrick.Altitude * 0.4f;

			// export the node
			textWriter.WriteLine("   <node>");
			textWriter.WriteLine("      <coordinates x=\"" + x.ToString(System.Globalization.CultureInfo.InvariantCulture) +
												"\" y=\"" + y.ToString(System.Globalization.CultureInfo.InvariantCulture) +
												"\" z=\"" + z.ToString(System.Globalization.CultureInfo.InvariantCulture) + "\"/>");
			textWriter.WriteLine("      <segments a=\"" + ConnectedBrickAId + "\" b=\"" + ConnectedBrickBId + "\"/>");
			textWriter.WriteLine("      <anchor value=\"no\"/>");
			BrickLibrary.ConnectionType connectionType = BrickLibrary.Instance.getConnexionTypeInfo(connectionPoint.Type);
			textWriter.WriteLine("      <type value=\"" + connectionType.FourDBrixName + "\"/>");
			textWriter.WriteLine("   </node>");
		}

		private static void saveOneTrackSegmentIn4DBrix(StreamWriter textWriter, FourDBrixPart part, Dictionary<LayerBrick.Brick.ConnectionPoint, int> connectionGlobalIndex)
		{
			// get the brick
			LayerBrick.Brick brick = part.mBrick;
			// start to write the segment
			textWriter.WriteLine("   <segment>");
			textWriter.WriteLine("      <index value=\"" + brick.GUID.ToString() + "\"/>");
			textWriter.WriteLine("      <type value=\"" + part.mRemapData.mPartName + "\"/>");
			textWriter.WriteLine("      <label value=\"\"/>");
			// the saving of an origin index which is different from 0 in a ncp file is totally bugged in nControl,
			// because nControl will keep that value, but totally mess up the part when reloading it.
			// so we need to always save the ncp file with a origin set as 0
			// however, if the origin connection is different in nControl and BlueBrick, we need to 
			// save all the connection point in order, but starting with the ncp origin
			// so that we can write "origin=0" later
			if (brick.HasConnectionPoint)
			{
				textWriter.WriteLine("      <nodes value=\"" + brick.ConnectionPoints.Count + "\"/>");
				int localIndex = 1; // the local index is just used for the name of the xml tag, and starts with 1
				// start from the origin index
				int i = part.mRemapData.mConnectionIndexUsedAsOrigin;
				do
				{
					// get the current connection
					LayerBrick.Brick.ConnectionPoint connection = brick.ConnectionPoints[i];
					// get the global index of the current connection (this should never fail)
					int globalIndex = 0;
					connectionGlobalIndex.TryGetValue(connection, out globalIndex);
					// then write the line
					textWriter.WriteLine("      <node" + localIndex.ToString() + " value=\"" + globalIndex.ToString() + "\"/>");
					localIndex++;
					// increase the index, if we reach the end, loop it from 0
					i++;
					if (i == brick.ConnectionPoints.Count)
						i = 0;
					// and stop the loop, when we reach again the origin
				} while (i != part.mRemapData.mConnectionIndexUsedAsOrigin);
			}
			textWriter.WriteLine("      <angle value=\"" + (brick.Orientation + part.mRemapData.mOrientationDifference).ToString(System.Globalization.CultureInfo.InvariantCulture) + "\"/>");
			// alway write that the origin local index node is 0, because we wrote the node id by starting from the origin defined in the part description
			// nControl is bugged and does not support well an origin index different from 0
			textWriter.WriteLine("      <origin value=\"0\"/>"); 
			// in BlueBrick the part can have elevation, but not slope (they are always horizontal
			textWriter.WriteLine("      <slope value=\"0\"/>");
			textWriter.WriteLine("   </segment>");
		}

		private static void saveTracksIn4DBrix(StreamWriter textWriter, List<FourDBrixPart> tracks)
		{
			// 4DBrix share the connections points between tracks, but BlueBricks give a connection point to each brick
			// so we need to create a list of unique connection points and remove the connection points at the same place.
			List<LayerBrick.Brick.ConnectionPoint> allNodes = new List<LayerBrick.Brick.ConnectionPoint>();
			Dictionary<LayerBrick.Brick.ConnectionPoint, int> connectionGlobalIndex = new Dictionary<LayerBrick.Brick.ConnectionPoint, int>();

			// iterate on the brick list, because it's the bricks who holds their connection points
			// for each brick iterate on their connection points.
			foreach (FourDBrixPart part in tracks)
			{
				List<LayerBrick.Brick.ConnectionPoint> currentBrickConnectionPoints = part.mBrick.ConnectionPoints;
				if (currentBrickConnectionPoints != null)
					foreach (LayerBrick.Brick.ConnectionPoint connection in currentBrickConnectionPoints)
					{
						// Check if we need to add this connection in the list or if a connection at the same place is already in
						// if the brother to which I'm linked, is already in the global list that means I would be redundant, so I should not be inserted
						if ((connection.ConnectionLink == null) || !connectionGlobalIndex.ContainsKey(connection.ConnectionLink))
						{
							// use the last index of the list as global index for this connection
							connectionGlobalIndex.Add(connection, allNodes.Count);
							allNodes.Add(connection);
						}
						else
						{
							// in such case, get the global index of my linked brother and add myself in the dictionary with his global index
							connectionGlobalIndex.Add(connection, connectionGlobalIndex[connection.ConnectionLink]);
						}
					}
			}

			// now iterate on all the nodes to save them
			foreach (LayerBrick.Brick.ConnectionPoint connection in allNodes)
				saveOneNodeIn4DBrix(textWriter, connection);

			// then iterate on all the bricks to same them
			foreach (FourDBrixPart part in tracks)
			{
				// save the brick
				saveOneTrackSegmentIn4DBrix(textWriter, part, connectionGlobalIndex);
				// step the progress bar for this brick for the second pass
				MainForm.Instance.stepProgressBar();
			}
		}

		private static void saveGenericPartsIn4DBrix(StreamWriter textWriter, List<FourDBrixPart> partList, string partTag, bool isCoordInCenter)
		{
			// get the tag used for saving the coordinates
			string coordTag = isCoordInCenter ? "center" : "coordinates";
			bool needToSaveSize = !partTag.Equals("table");

			foreach (FourDBrixPart part in partList)
			{
				// we need to rotate the part first before asking it's top left corner
				part.mBrick.Orientation = part.mBrick.Orientation + part.mRemapData.mOrientationDifference;
				// get the position in stud coordinates of the top left corner (as this is what nControl use to place tables)
				PointF position = isCoordInCenter ? part.mBrick.Center : part.mBrick.TopLeftCornerPositionInStud;
				textWriter.WriteLine("   <" + partTag + ">");
				// save the position in milimeters
				textWriter.WriteLine("      <" + coordTag + " x =\"" + (position.X * 8f).ToString(System.Globalization.CultureInfo.InvariantCulture) +
															"\" y=\"" + (position.Y * 8f).ToString(System.Globalization.CultureInfo.InvariantCulture) + "\"/>");
				textWriter.WriteLine("      <angle value=\"" + part.mBrick.Orientation.ToString(System.Globalization.CultureInfo.InvariantCulture) + "\"/>");
				textWriter.WriteLine("      <svgfile value=\"" + part.mRemapData.mPartName + "\"/>");
				// special case for baseplates and structures they want the size in studs
				if (needToSaveSize)
				{
					// the width and height are the one of the baseplate without rotation for ncontrol, so we ask it to the part library
					// nControl wants the baseplate size is in millimeter, one stud = 8 mm, and the brick resolution is 8 pixel per stud. So 1 px = 1 mm, we can use the image size in pixel.
					Image brickImage = BrickLibrary.Instance.getImage(part.mBrick.PartNumber);
					textWriter.WriteLine("      <size height=\"" + brickImage.Height + "\" width=\"" + brickImage.Width + "\"/>");
				}
				textWriter.WriteLine("   </" + partTag + ">");
				// rotate back the brick to its original orientation
				part.mBrick.Orientation = part.mBrick.Orientation - part.mRemapData.mOrientationDifference;
				// step the progress bar for this brick for the second pass
				MainForm.Instance.stepProgressBar();
			}
		}

		private static void saveGroupsIn4DBrix(StreamWriter textWriter, List<LayerBrick.Group> groupList)
		{
			foreach (LayerBrick.Group group in groupList)
			{
				textWriter.WriteLine("   <group>");
				// write the segment list
				textWriter.Write("      <segments list=\"");
				List<Layer.LayerItem> brickList = group.getAllLeafItems();
				for (int i = 0; i < brickList.Count; ++i)
				{
					Layer.LayerItem brick = brickList[i];
					textWriter.Write(brick.GUID.ToString());
					if (i < brickList.Count - 1)
						textWriter.Write(",");
				}
				textWriter.WriteLine("\"/>");
				// write the bounding box
				textWriter.WriteLine("      <boundingbox x=\"" + (group.DisplayArea.X * 8).ToString(System.Globalization.CultureInfo.InvariantCulture) +
														"\" y=\"" + (group.DisplayArea.Y * 8).ToString(System.Globalization.CultureInfo.InvariantCulture) +
														"\" w=\"" + (group.DisplayArea.Width * 8).ToString(System.Globalization.CultureInfo.InvariantCulture) +
														"\" h=\"" + (group.DisplayArea.Height * 8).ToString(System.Globalization.CultureInfo.InvariantCulture) + "\"/>");
				textWriter.WriteLine("   </group>");
			}
		}

		private static void saveFooterIn4DBrix(StreamWriter textWriter)
		{
			textWriter.WriteLine("</data>");
		}

		private static bool save4DBrix(string filename)
		{
			// init the progress bar with the number of items (+1 for init remap +1 for header so start with 2)
			// and we count the number of items twice because there're 2 passes
			int nbItems = 2;
			foreach (Layer layer in Map.Instance.LayerList)
				if (layer is LayerBrick)
					nbItems += (layer.NbItems * 2);
			MainForm.Instance.resetProgressBar(nbItems);

			// step the progressbar after the init of part remap
			MainForm.Instance.stepProgressBar();

			StreamWriter textWriter = new StreamWriter(filename, false, new UTF8Encoding(false));
			// write the header
			saveHeaderIn4DBrix(textWriter, filename);

			// step the progressbar after the write of the header
			MainForm.Instance.stepProgressBar();

			// 4DBrix only have 4 fixed layers, so we need to split the bricks of all the layers in 4 different list
			List<FourDBrixPart> tables = new List<FourDBrixPart>();
			List<FourDBrixPart> tracks = new List<FourDBrixPart>();
			List<FourDBrixPart> baseplates = new List<FourDBrixPart>();
			List<FourDBrixPart> structures = new List<FourDBrixPart>();
			List<LayerBrick.Group> groups = new List<LayerBrick.Group>();

			// iterate on all the layers of the Map
			foreach (Layer layer in Map.Instance.LayerList)
			{
				if (layer is LayerBrick)
				{
					LayerBrick brickLayer = layer as LayerBrick;
					foreach (LayerBrick.Brick brick in brickLayer.BrickList)
					{
						// if the brick is part of a group, add the group in the group list (if not already in)
						if (brick.Group != null)
						{
							// because 4DBrix doesn't support hierachical groups, we flatten all the trees, 
							// and group all the children leaves in their same top group.
							Layer.Group topGroup = brick.TopGroup;
							if (!groups.Contains(topGroup))
								groups.Add(topGroup);
						}

						// create a struct to combine the remap data and the brick
						FourDBrixPart part = new FourDBrixPart() { mRemapData = BrickLibrary.Instance.get4DBrixRemapData(brick.PartNumber), mBrick = brick };
						// add the part in the correct list according to the remapdata type (if it exists, otherwise, ignore the part)
						if (part.mRemapData != null)
						{
							switch (part.mRemapData.mFourDBrixBrickType)
							{
								case BrickLibrary.Brick.FourDBrixRemapData.FourDBrixBrickType.SEGMENT:
									tracks.Add(part);
									break;
								case BrickLibrary.Brick.FourDBrixRemapData.FourDBrixBrickType.TABLE:
									tables.Add(part);
									break;
								case BrickLibrary.Brick.FourDBrixRemapData.FourDBrixBrickType.BASEPLATE:
									baseplates.Add(part);
									break;
								case BrickLibrary.Brick.FourDBrixRemapData.FourDBrixBrickType.STRUCTURE:
									structures.Add(part);
									break;
								default:
									structures.Add(part);
									break;
							}
						}
						else
						{
							// if the current item is skiped (not inserted in the list), then step the progress bar, to skip also its second phase)
							MainForm.Instance.stepProgressBar();
						}

						// step the progress bar for this brick for the first pass
						MainForm.Instance.stepProgressBar();
					}
				}
			}

			// then save the different layers in the correct order
			saveTracksIn4DBrix(textWriter, tracks);
			saveGenericPartsIn4DBrix(textWriter, tables, "table", false);
			saveGenericPartsIn4DBrix(textWriter, baseplates, "baseplate", false);
			saveGenericPartsIn4DBrix(textWriter, structures, "structure", true);
			saveGroupsIn4DBrix(textWriter, groups);

			// save the footer to finish the file
			saveFooterIn4DBrix(textWriter);

			// close the file
			textWriter.Close();

			return true;
		}
		#endregion
	}
}
